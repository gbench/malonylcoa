# R语言系统学习笔记

## 一、函数与闭包

### 1.1 函数基础与闭包概念

在R中，函数是一种被称为闭包（closure）的结构，包含三个基本组件：

```r
# 闭包示例
closure <- function(i) function(x) x^i

# 创建闭包函数
c4 <- closure(4)
c4(1:10)  # [1]    1   16   81  256  625 1296 2401 4096 6561 10000

# 访问和修改闭包环境
get("i", environment(c4))  # [1] 4
assign("i", -4, environment(c4))
c4(1:10)  # [1] 1.0000000 0.0625000 0.0123457 0.0039062 0.0016000 0.0007716 0.0004165 0.0002441 0.0001524 0.0001000
```

### 1.2 惰性求值（Lazy Evaluation）

R使用Promise对象实现惰性求值，Promise是一个三元组（expression, value, environment）：

```r
# 惰性求值的问题示例
f <- function(i) function(x) x^i
fs <- list()
for(i in 1:5) fs[[i]] <- f(i)

# 所有函数的i值都变成了5（因为惰性求值）
lapply(fs, do.call, args=list(1:10)) |> do.call(cbind, args=_)

# 解决方法：使用force强制立即求值
f2 <- function(i) {force(i); function(x) x^i}
fs2 <- list()
for(i in 1:5) fs2[[i]] <- f2(i)
lapply(fs2, do.call, args=list(1:10)) |> do.call(cbind, args=_)
```

### 1.3 函数调用堆栈

```r
# 函数调用堆栈分析
inner_f <- function(x) list(
    call = sys.call(),
    calls = sys.calls(),
    nframe = sys.nframe(),
    frms = sys.frames(),
    flag = identical(sys.frame(sys.nframe()), environment()),
    ge = sys.frame(),
    frm0 = sys.frame(0),
    pfs = sys.parents(),
    fs = sapply(1:sys.nframe(), \(i) parent.env(sys.frame(i)))
)
outer_f <- function(x) inner_f(x)
outer_f(x)
```

## 二、函数式编程

### 2.1 高阶函数应用

```r
# 使用Reduce和callCC实现提前终止的累加
xs <- seq(10) |> rev()
with((\(n=0) list(.i=\() n, .next=\() n<<-n+1))(),
    callCC(\(k) Reduce(init=0, x=xs, f=\(acc, a, i=.i())
        if(.next()<10) {cat("#", i, ":", a, "\n"); acc+a} else k(acc))))

# 嵌套循环的函数式实现
matrix(1:5, nrow=5, ncol=2, dimnames=list(NULL,c("x","y"))) |> data.frame() |> 
    expand.grid() |> apply(1,\(p)with(as.list(p),x+y)) |> matrix(ncol=5)
```

### 2.2 空间分解与数据组织

```r
# 高维数组组织数据
as <- with(warpbreaks, breaks |> structure(dim=c(9, 3, 2), 
           dimnames=list(gl(9, 1), levels(tension), levels(wool))))

# 使用apply进行维度统计
rs1 <- as |> apply(MARGIN=c(3, 2), FUN=summary)

# 与aggregate分组统计对比
rs2 <- aggregate(breaks~wool+tension, data=warpbreaks, FUN=summary)
```

## 三、元编程

### 3.1 表达式构建与操作

```r
# 使用bquote构建表达式
Reduce(f=\(acc, a) bquote(.(acc) + .(a)), x=sapply(letters, as.symbol))

# 移动平均过程的形式化定义
ma <- \(q) seq(0, q) |> as.numeric() |>
  lapply( \(i) 
    if(i==0) quote(nu + eps[t])
    else bquote(theta[.(i)] * eps[t - .(i)])
  ) |> Reduce(f=\(acc, a) bquote(.(acc) + .(a)))

ma(4)  # 生成4阶移动平均表达式
```

### 3.2 语法树操作

```r
#' 语法树替换函数
astsub <- function(x, pattern, replacement) {
  sub <- function(expr) {
    if (if(is.function(pattern)) pattern(expr) else identical(expr, pattern)) {
      if (is.function(replacement)) replacement(expr) else replacement
    } else if (is.call(expr)) {
      as.call(lapply(expr, sub))
    } else {
      expr
    }
  }
  sub(x)
}

# 示例：替换表达式中的模式
astsub(quote(a + (b + c)), quote(b + c), quote(b * c + d))
```

### 3.3 代码生成与执行

```r
# 动态生成并执行代码
expression(hist(), getElement('LastPrice'), rbindlist(), 
           lapply(FUN=read.csv), head(n=3), sort(decreasing=T),
           grep(pattern="\\.csv$", value=T)) |>
  Reduce(\(f, x, keys=names(formals(get(f[[1]]))), 
                k=setdiff(keys, names(f[-1]))[1]) {
       f[[k]] <- x; f
  }, x=_, init=quote(list.files()), right=T) |> eval()
```

## 四、数据处理

### 4.1 长宽格式转换

```r
# reshape函数进行长宽格式转换
# 宽转长
data <- reshape(
  direction = "long",
  data = iris |> transform(Id = 1:150),
  idvar = "Id",
  varying = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width"),
  timevar = "Part",
  sep = "."
)

# 长转宽
widedata <- reshape(
  data = longdata, 
  direction = "wide", 
  idvar = "Id",  
  v.names = c("Sepal", "Petal"), 
  timevar = "Part", 
  sep = "_"
)

# tidyverse方法对比
# pivot_wider 对应 reshape的 long -> wide
# pivot_longer 对应 reshape的 wide -> long
```

### 4.2 数据分组与聚合

```r
# 基本分组操作
pgn <- function(ps=1:3, gn=length(ps)) 
  rep(ps, gn) |> split(rep(paste0("x", seq(gn)), rep(length(ps), gn))) |> expand.grid()

# 应用：三叉树模型收益分布分析
pgn(-1:1, 5) |> 
  (\(x) transform(x, sum=apply(x, 1, sum))) () |> 
  (\(x) split(x, x$sum)) () |> 
  lapply(nrow) |> 
  (\(y, x=names(y)) {
    plot(x, y, type="b", 
         xlab="收益情况", ylab="分布频数",
         main="三叉树模型-收益分布", sub="投资5期收益分布")
    p <- (\(nums=unlist(y), v=nums/sum(nums)) paste0(round(v*100, 2), "%")) ()
    text(x, y, labels=paste(x, y, p, sep=" , "))
  }) ()
```

### 4.3 矩阵操作与分组

```r
# 矩阵按行/列分组
m <- matrix(1:10, ncol=5)

# 按行分组
split(m, row(m))

# 按列分组  
split(m, col(m))

# dplyr分组操作
dfm %>% group_by(k=gl(dim(.)[1], 1)) |> mutate(s=paste(x1, x2, LA, LE, k, sep="=>"))
dfm %>% rowwise() |> mutate(s=sum(x1, x2))  # 行计算
```

### 4.4 cut函数分组

```r
# cut函数详解
xs <- 1:10

# 使用断点数量分组
cut(xs, 3)

# 使用断点向量分组
cut(xs, c(0, 4, 8, 11))

# 区间开闭控制
cut(xs, c(0, 4, 8, 10), include.lowest=F, right=T)  # (0,4] (4,8] (8,10]
cut(xs, c(0, 4, 8, 10), include.lowest=F, right=F)  # [0,4) [4,8) [8,10)
cut(xs, c(0, 4, 8, 10), include.lowest=T, right=T)  # [0,4] (4,8] (8,10]
cut(xs, c(0, 4, 8, 10), include.lowest=T, right=F)  # [0,4) [4,8) [8,10]
```

## 五、金融计算应用

### 5.1 复利计算与金融工具分析

```r
#' 二分法求根
bisect <- function(f, a=0, b=1, eps=1e-10) {
  (\(fa, fb=f(b)) {
    if (abs(fa)<eps) a
    else if (abs(fb)<eps) b
    else if (fa*fb>0) NA
    else {
      repeat {
        assign('c', (a+b)/2)
        if(abs(assign('fc', f(c)))<eps || abs(b-a)<eps) break
        assign('flag', fa*fc<0)
        if(!flag) assign('fa', fc)
        assign(ifelse(flag, 'b', 'a'), c, parent.frame())
      }
      c
    }
  }) (f(a))
}

#' 净现值函数
npv <- function(rate, pmts, price) sum(pmts*(1+rate)^-(1:length(pmts))) + price

#' 等额本息支付工具的结构拆解
strips <- function(ps, price=10000) {
  n <- length(ps)
  pmts <- ps
  rate <- bisect(\(r) npv(r, -pmts, price))
  pvs <- pmts * (1+rate)^-seq(n)
  interest <- pmts - pvs
  data.frame(pvs, pmts, rate, interest)
}
```

### 5.2 头寸资产与期权策略

```r
#' 头寸资产分析
positions <- \(kc, pc, kp, pp, nc=1, np=1, price=1:100, ylim=NULL) 
  data.frame(price=price) |> with({
    (if(c(nc, np) |> is.na() |> all()) {
        old <- par(mfrow=c(2, 2)); on.exit(par(old))
        expand.grid(rep(list(c(-1, 1)), 2))
      } else {
         data.frame(nc=nc, np=np)  
    }) |> apply(1, \(p) {
      main <- sprintf("期权合约示意图:(%s)", paste0(p, collapse=","))
      rc <- (pmax(price-kc, 0) - pc) * p[1]
      rp <- (pmax(kp-price, 0) - pp) * p[2]
      ra <- rc + rp
      scale_range <- \(range, ratio=.1, center=mean(range)) center + (range - center) * (1 + ratio)
      ylim <- if(!is.null(ylim)) if(length(ylim)==2) ylim else range(ylim) 
               else scale_range(range(c(rc, rp, ra)))
      plot(price, rc, type='l', col="red", main=main, ylab="income", ylim=ylim)
      lines(rp, col="green")
      lines(ra, col="blue")
    })
  })

# 示例：同时买入看涨与看跌期权
positions(36, 1.7, 39, 1.9, , , 1:70)
```

## 六、环境与命名空间

### 6.1 环境结构与管理

```r
# 环境闭包遍历
envclos <- \(x=sys.frame(sys.nframe()), ret=list()) 
  if(identical(emptyenv(), x)) ret else parent.env(x) |> envclos(append(x, ret))

# 查看当前环境链
envclos()

# 搜索路径
search()
searchpaths()
```

### 6.2 包加载机制

```r
# 查看函数所在环境
environment(install.packages)  # <environment: namespace:utils>
pryr::where('install.packages')  # <environment: package:utils>

# 证明namespace环境与package环境不同
(\(nsenv=environment(install.packages), pkgenv=pryr::where('install.packages')) 
  identical(nsenv, pkgenv)) ()  # FALSE

# 环境中的对象数量对比
(\(nsenv=environment(install.packages), pkgenv=pryr::where('install.packages')) 
  structure(c(nsenv, pkgenv), names=c('nsenv', 'pkgenv')) |> lapply(length)) ()
# $nsenv: 639, $pkgenv: 263
```

### 6.3 环境层次结构

以ggplot2为例的环境链：
```
geom_point的实际环境 (0x...)
  → 命名空间环境: namespace:ggplot2
    → 导入环境: imports:ggplot2
      → 基础命名空间: namespace:base
        → 空环境
```

搜索路径关系：
```
运行环境: R_GlobalEnv
  → 包环境: package:ggplot2
    → 包环境: package:stats
      → ... (其他包环境)
        → package:base
          → Autoloads
            → namespace:base
              → 空环境
```

## 七、实用工具函数

### 7.1 字符串处理

```r
#' 去除字符串首尾空格
trim = \(x) sub("^\\s*(.+?)\\s*$", "\\1", x) |> (\(.) ifelse(.==" ", character(1), .))()
```

### 7.2 数据导出

```r
#' 导出函数源码到文件
export <- \(x, dir=".") {
  if(!dir.exists(dir)) dir.create(dir, recursive=T)
  nm <- if(is.character(x)) x else substitute(x) |> deparse()
  (if(is.character(x)) eval(as.symbol(x)) else x) |> deparse() |> 
    (\(x, f=file(file.path(dir, paste0(nm, '.R')), 'w')) {
      on.exit(close(f))
      cat(paste(x, collapse='\n'), file=f)
    }) ()
}
```

### 7.3 排序函数

```r
#' 安全的数据排序函数
descend <- \(data, decreasing=T, ...) 
  substitute(data[order(..., decreasing=decreasing), ]) |> 
  eval(envir=list2env(data, parent=parent.frame()))
```

### 7.4 包管理

```r
#' 批量操作函数
batch <- function(cmd, pkgs) 
  pkgs |> strsplit(",") |> `[[`(_,1) |> sapply(\(pkg) eval(substitute(f(p), list(f=cmd, p=pkg))))

# 批量安装包
batch(install.packages, "readxl,purrr,dplyr")

# 批量加载包  
batch(require, "readxl,purrr,dplyr")
```

## 八、R包开发

### 8.1 基础包创建

```r
# 使用package.skeleton创建包框架
foo <- function(x) x+1
package.skeleton('mypkg2', environment = .GlobalEnv)

# 编译和安装包
# 命令行执行：
# Rcmd build mypkg2
# R CMD INSTALL mypkg2_1.0.tar.gz
```

### 8.2 使用devtools开发包

```r
library(devtools)

# 创建包项目
create_package(path='mypkg3')
setwd('mypkg3')

# 添加必要文件
use_readme_rmd()
use_mit_license()

# 编写函数并添加文档
#' 导出函数源码
#' @param x 函数符号或名称
#' @param dir 导出目录
#' @export
export <- \(x, dir=".") {
  # 函数实现
}

# 生成文档
document()

# 检查包
check()

# 构建包
build()
```

### 8.3 R6面向对象编程

```r
library(R6)

#' R6类创建辅助函数
r6class <- \(clazzName, env=.GlobalEnv, ...) {
  cname <- substitute(clazzName) |> deparse()
  append(list(...), cname, 0) |> do.call(R6Class, args=_) |> 
    assign(x=cname, value=_, envir=env)
  env[[cname]]
}

# 创建User类
r6class(User,
  private = list(
    name = NULL,
    password = 123456
  ),
  public = list(
    initialize = \(name=NULL, password=123456) {
      private$name <- name
      private$password <- password
    },
    getName = \() private$name,
    setName = \(name) private$name <- name,
    getPassword = \() private$password,
    setPassword = \(password) private$password <- password
  )
)

# 使用类
User$new("zhangsan") -> u
u$getName()
u$setName('lisi')
u2 <- u$clone()
```

## 九、可视化与图形

### 9.1 ggplot时间序列坐标轴

```r
# 处理非连续交易时间的数据可视化
partition <- \(line, delim=",") line |> strsplit(delim) |> unlist()
as.datetime <- partial(as.POSIXct, format="%H:%M:%S")

# 生成交易时间段的分段坐标轴
breaks <- "09:00:00,10:15:00;10:30:00,11:30:00;13:30:00,15:00:00;20:00:00,23:00:00" |>
  partition(delim=";") |>
  lapply(\(line, ps=compose(as.datetime, partition)(line), interval="15 min") 
         seq(ps[1], ps[2], by=interval)) |>
  Reduce(c, init=as.POSIXct(character(0)), x=_)

# 自定义ggplot坐标轴
ggplot(dfm, aes(seq_along(index(dfm)))) +
  geom_line(aes(y=Close)) +
  scale_x_continuous(
    breaks=\(x) {
      tp <- c("10:15:00", "11:30:00", "15:00:00") |> as.datetime()
      breaks <- std.breaks[-match(tp, std.breaks)]
      match(breaks, index(dfm)) |> na.omit()
    },
    labels=\(x) {
      points <- index(dfm)[x]
      p1030 <- as.datetime("10:30:00")
      p1330 <- as.datetime("13:30:00")
      p2100 <- as.datetime("21:00:00")
      dplyr::case_when(
        points == p1030 ~ "10:15/30",
        points == p1330 ~ "11/13:30:00",
        minute(points) == 0 & points == p2100 ~ "15/21:00",
        minute(points) == 0 ~ format(points, "%H:00"),
        TRUE ~ sprintf("%02d", minute(points))
      )
    }
  ) +
  labs(x = "时间", y = "收盘价格", title = "价格线图")
```

## 十、常见问题与技巧

### 10.1 常见错误

```r
# 读取含日期时间的Excel数据时出现串列
# 错误：read.table默认sep=" "是空格
# 正确：指定sep='\t'
xs <- read.table('clipboard', sep='\t', header=T) |> tibble()
```

### 10.2 性能优化

```r
# 减少函数调用提升性能
# 原始版本可能多次调用f(a)，优化版本缓存fa结果
bisect <- function(f, a=0, b=1, eps=1e-10) {
  (\(fa, fb=f(b)) {  # 缓存f(a)和f(b)的结果
    # ... 计算逻辑
  }) (f(a))  # 计算并缓存f(a)
}
```

### 10.3 R语言缩写速查

- **基础语法**：
  - w/: with（带有）
  - obs.: observations（观测值）
  - var.: variable（变量）
  - chr: character（字符型）
  - int: integer（整型）
  - num: numeric（数值型）
  - logi: logical（逻辑型）

- **函数命名**：
  - arg: argument（参数）
  - col: column（列）
  - row: row（行）
  - mat: matrix（矩阵）
  - df: data.frame（数据框）
  - vec: vector（向量）
  - fun: function（函数）
  - stat: statistic（统计量）
  - geom: geometry（几何对象）
  - fit: fit（拟合）
  - res: residuals（残差）
  - coef: coefficients（系数）
  - summ: summary（汇总）

### 10.4 在线R环境

1. **WEBR**：https://webr.r-wasm.org/latest/ - WebAssembly版本的R
2. **Programiz**：https://www.programiz.com/r/online-compiler/ - 在线R编译器
3. **rdrr**：https://rdrr.io/snippets/ - R代码片段分享

## 总结

这份笔记系统整理了R语言的核心概念和实用技巧，从基础语法到高级特性，涵盖函数式编程、元编程、数据处理、金融计算、包开发等多个方面。重点包括：

1. **函数与闭包**：理解R中函数的闭包本质和惰性求值机制
2. **函数式编程**：掌握高阶函数、递归、循环替代等函数式编程范式
3. **元编程**：学习表达式操作、代码生成和语法树变换
4. **数据处理**：熟悉长宽格式转换、分组聚合和矩阵操作
5. **环境管理**：理解R的环境系统和包加载机制
6. **实用开发**：掌握包开发流程、调试技巧和性能优化

通过系统学习这些内容，可以深入理解R语言的设计哲学，编写出更高效、更优雅的R代码。