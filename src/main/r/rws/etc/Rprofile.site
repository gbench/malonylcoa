# Things you might want to change

# options(papersize="a4")
# options(editor="notepad")
# options(pager="internal")

# set the default help type
# options(help_type="text")
  options(help_type="html")

# set a site library
# .Library.site <- file.path(chartr("\\", "/", R.home()), "site-library")

# set a CRAN mirror
# local({r <- getOption("repos")
#       r["CRAN"] <- "http://my.local.cran"
#       options(repos=r)})

# Give a fortune cookie, but only to interactive sessions
# (This would need the fortunes package to be installed.)
#  if (interactive()) 
#    fortunes::fortune()

# --------------------------------------------------------------------------------------
## 参数设置

# 本地环境参数设置:
  options( # sqlquery的数据库参数预先设置
  #  sqlquery.drv=MySQL(), # 数据库驱动
    sqlquery.host="127.0.0.1", # 数据库主机
    sqlquery.user="root", # 数据库用户
    sqlquery.password="123456", # 数据库密码
    sqlquery.port=3371, # 数据库端口
    sqlquery.dbname="ctp", # 数据库名
    sqlquery.schema="public,economics", # sqlquery.schema一般为PostgreSQL的参数配置，而MySQL通常不予使用
  #  sqlquery.rb.timestamp=(\(times=0, period=24*3600) (\() {on.exit(times<<-times+1); Sys.time()+times*period})) (), # 带状态时间戳生成函数
    sqlquery.rb.keys="##tbl,#startime,#endtime", # 结构记录构建器默认键名序列
    sqlquery.rb.interval=3, # 结构记录构建器默认时间时间跨度
    sqlquery.rb.instrument="rb2605", # 结构记录构建器默认合约
    sqlquery.env.pkgs = "RMySQL,tidyverse,jsonlite,quantmod,data.table,janitor,RPostgres" # 环境依赖包！
  ) # 本地环境参数设置

# --------------------------------------------------------------------------------------
#环境设置

# .sqlqueryenv的自举构建
eval(quote({ # 自举构建具体过程逻辑

  # --------------------------------------------------------------------------------------
  ## 自举环境常量设置
  
  .sqlqueryenv <- environment() # 提取运行环境（new.env()所创建的对象即运行环境自己）
  attr(.sqlqueryenv, "name") <- ".sqlqueryenv" # 为环境命名，这样print(.sqlqueryenv) 就会有一个符号名字！
  rws_home <- "F:/slicef/ws/rws" # R工作区目录
  rscript_home <- Sys.getenv('RSCRIPT_HOME') # 工具脚本与资源文件目录
  dailywork_home <- sprintf("%s/dwk/%s", rws_home, Sys.Date()) # 每日工作区目录
  
  # --------------------------------------------------------------------------------------
  # 自举工具函数定义

  #' 创建一个目标目录
  #' 
  #' 根据输入的目录路径，递归地创建目录。
  #' 
  #' @param x 目录路径，例如 "/the/file/path"
  #' @return 无返回值，主要作用是创建目录
  #' @export
  mkdir <- function(x) {
    tryCatch({
      if (!dir.exists(x)) {
        dir.create(x, recursive = TRUE)
        message(paste("Successfully created directory:", x))
      } else {
        message(paste("Directory already exists:", x))
      }
    }, error = function(e) {
      stop(paste("Failed to create directory:", x, "Error:", e$message))
    })
  }

  #' 制作延迟加载库
  #' 
  #' 把指定 envir 环境中的数据，写成 .rdb, .rdx 文件，以便日后进行 lazyLoad。
  #' 一旦生成了（.rdb, .rdx ）数据以后，可以采用如下方法来加载数据文件：
  #' lazyLoad(paste0(lazyloads_home, "/", dbname))
  #' 
  #' @param dbname 数据库名称（这里的额db不是关系数据库而是指 .rdb文件的名称）
  #' @param envir 指定的会话环境, 默认为当前的会话环境
  #' @param lazyloads_home 延迟数据库根目录，默认为 RSCRIPT_HOME 环境变量指定路径下的 lazyloads 文件夹
  #' @return 生成的延迟加载数据库文件的路径
  #' @export
  mklzdb <- function(dbname, envir = environment(), lazyloads_home = file.path(rscript_home, "lazyloads")) {
    # 创建延迟加载的数据根目录
    mkdir(lazyloads_home)
    
    # 构建目标文件路径
    target <- file.path(lazyloads_home, dbname)
    
    # 生成数据文件
    tryCatch({
      tools:::makeLazyLoadDB(envir, target)
      message(paste("Successfully created lazy load database at:", target))
    }, error = function(e) {
      stop(paste("Failed to create lazy load database at:", target, "Error:", e$message))
    })
    
    # 返回数据文件路径
    return(target)
  }

  #' 批量加载包
  #' @param xs 包名序列,元素间用逗号','分隔
  #' @param flag 是否采用require模式加载，T：require，F：library
  #' @export
  batch_load <- function(xs = getOption("sqlquery.env.pkgs", "RMySQL,tidyverse,jsonlite"), flag=T) {
    xs <- (if(length(xs) == 1 & is.character(xs)) strsplit(xs, "[,]+") |> unlist() else xs) |> sapply(trimws)
    xs |> sapply(\(x) tryCatch({ #尝试加载&安装x包
      if(!require(x, character.only=TRUE)) install.packages(x);
      (if(flag) require else library)(x, character.only=TRUE)
    }, error=\(e) e))
  }
  
  #' 工作环境构建
  #' @param F 是否读取RSCRIPT_HOME目录下的脚本资源文件来初始化
  #' @param envir 资源函数加载的环境位置
  rebuild_sqlquery <- \(flag=F, envir=.sqlqueryenv) {
    if (!dir.exists(dailywork_home)) mkdir(dailywork_home) # 创建工作目录
    setwd(dailywork_home) # 设置工作去目录
    
    if (flag) { # 根据指定模式加载数据文件
      # 自定义的预先加载的自定义函数文件列表
      
      myfiles <- list.files(path = rscript_home, pattern="\\.R$", recursive = T) 
      sprintf(fmt = "%s/%s", rscript_home, myfiles) |> lapply(sys.source, envir=envir) |> invisible()
      mklzdb("malonylcoa", envir) # 创建/更新layloads malonylcoa
    } else { # 延迟加载(.rdx, .rdb 文件)
      # 延迟数据库根目录 
      lazyloads_home <- paste0(rscript_home, "/lazyloads")
      # 启用延迟加载（lazyLoad只能加载一个文件所以使用lapply进行包装）
      lazyloads_home |> list.files(pattern = "*.rdb", full.names = T) |> sub("\\.(rdb)$", "", x=_) |> lapply(lazyLoad, envir=envir) |> invisible()
    } # if
    
    envir # 返回执行环境
  } # 工作环境构建

  # --------------------------------------------------------------------------------------
  # 返回自举环境
  
  .sqlqueryenv # 返回执行环境（eval的执行所在环境：new.env()的返回结果)!
}), envir=new.env()) |> with(rebuild_sqlquery(T)) |> attach(name=".SqlQueryEnv") #  附加到工作区，命名.SqlQueryEnv以供工作使用（仿照.GlobalEnv）！
