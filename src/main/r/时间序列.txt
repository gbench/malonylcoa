# --------------------------------------------------------------------------------------------------
# 基本时间术语与理论概念
# --------------------------------------------------------------------------------------------------
# 时间 与 时间的表述（形式化定义，将时间与数值进行关联&对应的理论基础，时间的计算原理）：
#
# 时间: 时间是对 运动 即 `纯过程持续 ` 的 线性 的 度量化描述。
#
# (主要符号与记法说明
#  =   表示值相等，  a  =  expression, 可以理解为a是expression的一种计算结果(可能是一种中间的计算状态,不一定是最终的最简结果形式)。
#  ::= 表示 定义为， a ::= expression, 可以理解为符号a由表达式expression定义；
#  <==> 表示 等价于  expression1 <=> expression2 可以理解为书写&记录方式expression1与expression2表达相同的内容；
#  :: 表示 类型约束  a :: A 表示 a是类型A的一个实例对象，a的主要特定和性质由A进行定义和描述。
#  inspire current 则 类似于 haskell 的 `函数应用` 概念 即 Inspire :: t ->t 是函数/映射，一种到自身同种类型的映射关系或者说变换.
# ）
#
# 所谓 `纯过程持续` 是指一种递归式 的 启发关系（通过 `现有` 创造&新生 出 `后继`）Inspire :: t->t
# 即 持续不断的 将某种 current 当前 Inspire 为 之后 的 next, 形式化 的 表述 就是:
#
# (1)  next           ::= inspire current
#      <==> next1     ::= inspire current. 此时扩展以一下"上述的形式记法", 将 next0 ::=current, next1::= next 则
#      <==> next1     ::= inpire next0， 或 inspire^1 next0，这里再将 next0 ::= inspire^0， 我们继续递归应用 Inspire 则
# (2)  next next      ::= inspire next = inspire (inspire current) , 
#      <==> next2     ::= next next 
#      <==> next2     ::= (inpire . inspire) current. 此时扩展以一下上述的形式记法inpire . inspire ::= inpire^2
#      <==> next2     ::= inspire^2 current  
#      <==> next2     ::= inpire^2 next0
# (3)  next next next ::= inspire (inspire (inspire current))
#      <==> next3     ::= inpire^3 next0
#      ... （持续不断对上述形式过程进行推导，我们就会很容获得以下的形式）
# (n)  nextn =        ::= inpire^n next0 
#      ...
#
# 由此，我们 为 过程 即 时间的描述内容 构造了一种 `序列化` 的 形式描述, 即
# 1) 静态的（结果/状态）即 活动结果序列：next0,       next1,       next2,      next3,       ..., nextn,       ... 
# 2) 动态的（关系/行为）即 活动方法序列：inspire^0, inspire^1, inspire^2, inspire^3, ..., inspire^n, ...
# 上述的 两个序列，统一一下, 即 t ::= next, 或是, t ::= inspire. 则, 它们将
# 时间统一成 一个简单 的 无限&连续的 序列化结构：t0, t1, t2, t3, ...., tn, ...
# 即 时间描述过程 的 形式化方法 就是 连续序列, OK，现在你可以说时间的结构就是连续序列了（因为它在形式上就这这个样子的）。
#
#  由此，我们 可以将 时间视为一种 对 `连续性的均匀客观存在` 即过程 [t0,t1,t2,t3,....,tn,...] 的 形式化编码系统，也就是 所谓的 时间系统。
#  (注意：此时的均匀是一种理想化，是人们为了美化和 叙述方便 & 分析处理 而 附加的意义，否则如何描述不均匀则会相当的麻烦与费事，哈哈。
#  其实，时间是否均匀，根本无所谓！因为（本文认为）时间的本质只是描述方式的符号编码系统（文法系统=词法+句法）是纯粹的记录&标点工具，
#  它只是描述意义，而其本身的意义相对于其所描述的内容而言并不重要，至少是不如内容重要，即什么时刻的那个XXX是要远远高于时刻数字本身的！
#  就像 你用 Apple 表示 苹果，りんご，アップル 去 表示苹果，对于苹果对象本身而言（注意，叙述者与聆听者除外，文化与经验对其非常重要，
#  一个不懂日语，或是 没见过苹果 的 美国人 可能对りんご 毫无反应，但它们已经不是"苹果对象"了，所以就"描述对象"而言，描述方式本身的意义
#  是可以不予考虑的，即 是次要矛盾！我们此处给予忽略）是丝毫不受影响的，因为：`客观存在`不以`主观意志`为转移)， 
#
# 时刻：我们称上述形式化的[t0,t1,t2,t3,....,tn,...]描述过程中的元素tn，称为该过程中的
# 1）某个特定活动结果 next^n     的时刻，或是
# 2）某个特定活动方法 inspire^n 的时刻。
# 有了上述的时刻概念，人们就很容以的可以进行 相应 的 
# 1）信息定位（检索）:  从现在向过去的 去查询 曾经 发生过的 事物 的 状态或是行为。
# 2)  组织安排（计划）：从现在向未来的 去计划 将要 控制&期望出现的 事物 的 状态或是行为。 即：将动作行为与特定的时间刻度或是时刻范围进行关联绑定。
# 即，通过时刻概念，人们拥有了操作 或者说 意识思想上 编辑（组织、安排、调度、设计，协调，解构&重构的理解和表达） 过程的能力。
#
# 时刻的意义：通过将 过程 以 时刻序列 ：[t0,t1,t2,t3,....,tn,...] 这样的方式描述， 人们就可 很方便的为 对应的 时空过程里 的 各个对象，去分配
#    相应的时间刻度标记，即 时刻索引，去 标识，记录，区分，绑定 该 对象 的 特征属性 至其相对应 的 时间位置 即 时刻，进而 构造出 一种 依赖于
#    时间 的 `状态` 即 映射关系S : 时间 -> 状态，或者 S: t->s ；结果，就可以 以a[t] 来标识&记录 对象的属性(attriute) 在 某个过程中 的 t时刻的状态。
#    时刻的出现 为 对象 的 生命周期（对象的从到死的整个过程），提供了一种形式化的描述方法，也可以，认为 是 建立了 一种 时间 的 思考维度。
#    所谓维度：或者说 维度的本质，就是一种特异化 的 对 事物对象 的 相关特征与属性进行 的 观察与思考 而 创造出来 的一系列(意识概念的)形式化的记录方法。
#      即 维度 建立了一种 描述对象 的 语言&思路(概念的演变路线)，i.e, 
#      维度，就是一种 人为 创建 的 对 对象 的 某种(其所感兴趣的)关键特征 即 价值意义&属性 的 在思想意识时空里 的 进行 表达与描述 的 手段和方式方法：维度空间。
#      维度空间（概念集合与相关的运算规则），为 观察与思考 提供了 建立 与 其相关 的 符号与记录文法 的 原料素材（将客观世界映射为语言化的文法符号）。
# 
# 时间系统的主要概念：
# Unix 时间戳：指从协调世界时（UTC）1970 年 1 月 1 日 00:00:00 起至某一时刻所经过的秒数, 也称 Unix 时间、POSIX 时间 。
# 时间epoch: 规定 上述系统里的next0的意义, unix 将uninx系统的诞生时刻规定为 时间形式系统里的 next0
#   或者说 上文的 形式化过程里 [t0,t1,t2,t3,....,tn,...] 中t0 
#   将其 绑定到 1970 年 1 月 1 日 00:00:00，
#   而后 规定 将 任意时刻t[i]其相邻的时刻，即 t[i-1], t[i+1] 之间的 距离，即时间长度 定义为 1s, 由此完成了 unix 时间戳 与 时刻的绑定。
# 时区：
#    背景介绍：
#        日常生活，时间往往与一定地区的自然现象相联系，比如早晨日出对应当地时间6:00左右, 中午：对应当地12：00, 傍晚对应当地17：00 左右等。
#       很自然当地时间方便 小范围的局部使用，但是 很不方便 大范围的 应用，比如：中国的中12：00 对应差不多美国的24：00， 由此就需要一种
#       靠虑到地球自传，各地区的经纬度坐标差异，既方便转换为当地时间又可以很容易对应到Unix 时间戳绝对时间的概念来供人类共同使用。
#       这就是时区概念需要解决的问题：
#   时区(Time Zone) :为了统一时间标准而划分的区域，全球共分为 24 个时区。
#        时区是根据地球自转产生的地方时差异来划分的。
#        规定英国（格林尼治天文台旧址）为中时区（零时区）、
#        东 1—12 区，西 1—12 区。每个时区横跨经度 15 度，时间正好是 1 小时。
#        最后的东、西第 12 区各跨经度 7.5 度，以东、西经 180 度为界
#  重要时区：
#    中时区，零时区，UTC: 以本初子午线为中央经线，是全球时间的基准时区，它的区时也被称为世界时（UTC）。许多国际标准和协议都以零时区的时间为参考
#    东八区: 京时间就是东八区的区时，它是中国大部分地区使用的标准时间。
#               由于中国领土跨度较大，从东五区到东九区共 5 个时区，但为了方便管理和使用，全国统一采用东八区的时间作为标准时间。
#
# iso8601 时间系统（统一记录与表达时间的方法）：
#    有了unix时间戳与时间epoch的定义，即 将时间编码成 整数数值，这无疑为时间的比较与计算带来了极大的便利，
#   但另一个问题随之而已，即使 数值化的 unix时间戳 或者说 时刻，非常不方便 日常交流，且 无法与 日常的周期化的节律性自然事件
#   进行关联，于是就诞生 关于日期和时间表示方法的国际标准：iso8601 时间系统。
#   
#   iso8601是国际标准化组织（ISO）制定的，它规定了一种统一、规范且简洁的方式来表示日期和时间。
#   以便在不同的计算机系统、数据交换和国际交流等场景中能够准确无误地理解和处理时间信息，
#   主要内容如下：
#   1) 基本格式
#   1.1) 日期表示：
#   1.1.1） 日期表示：采用年 - 月 - 日的顺序，用连字符 “-” 分隔，例如 2025-02-16。
#   1.1.2） 简化日期：可以省略连字符，如 20250216
#   1.2) 时间表示：
#   1.2.1)基本格式:   使用时：分: 秒的格式，如 15:30:00 表示下午 3 点 30 分整。
#   1.2.1)扩展格式:   如果需要更高的精度，还可以添加小数部分来表示秒的小数，如 15:30:00.5 表示下午 3 点 30 分 0.5 秒。
#   2) 组合格式:
#   2.1) 日期和时间可以组合在一起表示，中间用大写字母 “T” 分隔，如 2025-02-16T15:30:00，表示 2025 年 2 月 16 日下午 3 点 30 分。
#   2.2) 如果要表示特定的时区，可在时间后面加上时区标识。例如，
#          2025-02-16T15:30:00+08:00 表示东八区时间
#          2025-02-16T15:30:00Z 表示协调世界时（UTC）2025 年 2 月 16 日下午 3 点 30 分，“Z” 代表 UTC 时区，等同于 + 00:00。
#   3) 时间间隔表示
#        P模式: P3Y6M4DT12H30M 表示3年6个月4天12小时30分钟的时间间隔,其中"P"表示时间段,"Y","M","D","H","M"分别代表年,月,日,小时,分钟。
#        /模式: 在两个日期时间之间用"/"分隔来表示时间间隔,如:2025-02-16T00:00:00/2025-02-17T00:00:00 表示从2025年2月16日0点到2025年2月17日0点的时间间隔。
# 
# 主要地域化时间系统：
#     UTC：协调世界时（Coordinated Universal Time，UTC）是全球用于调节时钟和时间的主要时间标准，
#              它以原子时秒长为基础，在时刻上尽量与世界时接近，是一种更加精确和科学的时间计量方式。   
#     GMT：格林尼治标准时间（Greenwich Mean Time，GMT）: 是以位于英国伦敦郊区的皇家格林尼治天文台的本初子午线为标准的时间，
#             它是世界时（UT）的一种形式，曾经是全球时间的重要参考标准。
#     CST：表示多个不同的时间概念，常见的有以下两种（要根据上下文进行区分）
#              1） Central Standard Time (US & Canada)：即美国和加拿大的中部标准时间，属于西六区时间，比协调世界时（UTC）晚 6 个小时，
#                  在夏令时期间会调整为中部夏令时（CDT），比 UTC 晚 5 个小时。美国和加拿大的许多地区，如芝加哥、休斯顿等都使用 CST。
#              2）China Standard Time：即中国标准时间，属于东八区时间，比 UTC 早 8 个小时，是中国全国统一使用的时间标准，北京时间就是基于 CST。
#
# --------------------------------------------------------------------------------------------------
主要时间包&函数：
# --------------------------------------------------------------------------------------------------

# R 标识时间的方法：POSIXct，POSIXlt
# There are two basic classes of date/times. 
1） Class "POSIXct" represents the (signed) number of seconds since the beginning of 1970 (in the UTC time zone) as a numeric vector.
2 ）Class "POSIXlt" is internally a list of vectors with components named sec, min, hour for the time, mday, mon, and year, 
      for the date, wday, yday for the day of the week and day of the year, isdst, a Daylight Saving Time flag, 
      and sometimes (both optional) zone, a string for the time zone, and gmtoff, offset in seconds from GMT
# 简单的说POSIXct（chrono,continous 连续时间）记录的时间是一个数(与epoch之间的差)，而 POSIXlt (list列表形式)记录时间方式是一个列表。

# 系统时间
# Sys.time and Sys.Date returns the system's idea of the current date with and without time.
# 系统时间
> Sys.time()
[1] "2025-02-16 03:20:49 CST"
> Sys.time() |> class()
[1] "POSIXct" "POSIXt" 

# 系统日期
> Sys.Date()
[1] "2025-02-16"
> Sys.Date() |> class()
[1] "Date"

# POSIXct提取属性会报错
> (Sys.time()|>as.POSIXct())$year
Error in (as.POSIXct(Sys.time()))$year : 
  $ operator is invalid for atomic vectors

# POSIXlt提取属性则可以
> (Sys.time()|>as.POSIXlt())$year
[1] 125

# 时间的解析：string parse time
> strptime("2025-02-16 03:41:13", "%Y-%m-%d %H:%M:%S")
[1] "2025-02-16 03:41:13 CST"

# 时间的格式化：string f time
> strftime(Sys.time(), "%Y-%m-%d %H:%M:%S")
[1] "2025-02-16 03:44:13"

# 时区函数
> Sys.timezone()
[1] "Asia/Shanghai"

# 标准时间
> ISOdate(2024,2,16,12,34,5)
[1] "2024-02-16 12:34:05 GMT"

> ISOdate(2024,2,16,12,34,5, tz="Asia/Shanghai")
[1] "2024-02-16 12:34:05 CST"

> ISOdate(2024,2,16,12,34,5, tz="Asia/Tokyo")
[1] "2024-02-16 12:34:05 JST"

# 标准时间
> ISOdate(2024,2,16,12,34,5, tz=Sys.timezone())
[1] "2024-02-16 12:34:05 CST"

# 计算两个时间的差值
> ISOdate(2024,2,16,12,34,5, tz=Sys.timezone()) - ISOdate(2024,2,16,12,34,5)
Time difference of -8 hours

# 时间的差值是difftime
> (ISOdate(2024,2,16,12,34,5, tz=Sys.timezone()) - ISOdate(2024,2,16,12,34,5))|>class()
[1] "difftime"

# 计算两个时间按差值直接按的秒数
> difftime(ISOdate(2024,2,16,12,34,5, tz=Sys.timezone()), ISOdate(2024,2,16,12,34,5), units="secs") 
Time difference of -28800 secs

# 时刻与数字的运算数字被视为秒数的时间间隔
> strptime("2024-02-16",format="%Y-%m-%d") + 9
[1] "2024-02-16 00:00:09 CST"

# 指定时间间隔
> strptime("2024-02-16",format="%Y-%m-%d") + c(9, 30, 25) %*% c(3600, 60, 1)
[1] "2024-02-16 00:00:09 CST"

# 超过24小时的时间
> strptime("2024-02-16",format="%Y-%m-%d") + c(3*24+9, 30, 25) %*% c(3600, 60, 1)
[1] "2024-02-19 09:30:25 CST"

# --- lubridate
# 安装并加载 lubridate 包
if (!require(lubridate)) {
  install.packages("lubridate")
  library(lubridate)
}
# 解析日期字符串
start_date <- ymd("2024-02-16")
# 定义时间间隔
time_interval <- hours(9) + minutes(30) + seconds(25)
# 计算新的时间
new_time <- start_date + time_interval; new_time
 
> new_time <- start_date + time_interval; new_time
[1] "2024-02-16 09:30:25 UTC"

# ---
library(xts)
# timeBasedRange 是一个以ISO-8601格式去创建time-based objects 去以便索引 相关对象(xts object)的函数。
# 时间对象序列
> timeBasedSeq("2025-02-16 00:00:00/2025-02-16 00:00:5")
[1] "2025-02-16 00:00:00 CST" "2025-02-16 00:00:01 CST"
[3] "2025-02-16 00:00:02 CST" "2025-02-16 00:00:03 CST"
[5] "2025-02-16 00:00:04 CST" "2025-02-16 00:00:05 CST"

# 数据结构
> timeBasedSeq("2025-02-16 00:00:00/2025-02-16 00:00:5") |> str()
 POSIXct[1:6], format: "2025-02-16 00:00:00" "2025-02-16 00:00:01" "2025-02-16 00:00:02" "2025-02-16 00:00:03" ...

# 时间差值
> timeBasedSeq("2025-02-16 00:00:00/2025-02-16 00:00:5") |> diff()
Time differences in secs
[1] 1 1 1 1 1

# 5min
> timeBasedSeq('20250216 1200', length=5) 
$from
[1] "2025-02-16 12:00:00 CST"

$to
[1] NA

$by
[1] "mins"

$length.out
[1] 5

# 时间序列：从20241226到202501的日期序列
> timeBasedSeq('20241226/202501/d') |> range()
[1] "2024-12-26" "2025-01-31"

# --------------------------------------------------------------------------------------------------
# 时间序列：
# --------------------------------------------------------------------------------------------------
# 序列是一种结构：一种蕴含在 枚举&罗列的 表述&表达形式 之 下的过程结构（处理&运行）。
#
# 这种过程结构会把白噪声rnorm(n,mu,sigma)这样的毫无组织&规律的能量冲击{et}，给转换成一种连续&平滑的
# 即富有因果逻辑的结构f({et})，i.e, 连续就是结构。 它是一种可用规则表达式f来进行解析，可用有限次的初等运算给予
# 模拟&复制或是表达的。

# 我们认为：平滑是逻辑的形式结构，平滑就是逻辑（构建&描述事物的规则&方法），逻辑就是平滑，A->B->C-> ...  
# 这是一种无限的量变与质变的演化过程。
# 之所以，没有跳跃，没有出现倒退，那是因为： 存在的 某种耗费 额外能量 的 生命（意识）过程 来 对其进行 维持或者说管理&维护。
#
# 思考一个问题：
# 问题背景：
# 连续是一种无穷可分的概念。数学与物理的本质区别，就是 数学的 的 语言性，物理的本质 则是一种 现象的本质描述
# 观念，如同单词一样是一种词法记号，就像 用语言去描述世界一样，想法 或者说 思维观念 其 载体 就是这些 观念，
# 或者说 思维概念 的记号。我们可以 借助于 有限的 文字符号&记录规则 去表达 过去，现在&未来，其根本逻辑 
# 就是 语言的 主观与抽象性。它（连续）为我们提供一种囊括了未来预言的以现在认知去理解&表达的思维工具。
# 比如：假设目前，我们的科学技术 可以识别的最小粒子半径，是1e-10; 100年后，可以识别的最小粒子是半径 是 1e-100， 
# 一千年后是 1e-1000。
# 问题提问：
# 请问：当考虑到一千年以后，一万人年以后的情况， 以语言&逻辑的思维，对于粒子的半径这个概念需要如何描述，
# 才能够尽管未来的存在不可避免的未知，又可以足够准确的给予客观实际上的陈述&刻画？
#
# 显然，你需要创造出出 一个固定的符号r，用其去代表抽象概念（过去，现在，与未来），然后在设置一个动态的范围比如 r in Real 
# 即半径属于实数，再然后，再用连续性对其进行描述。
#
# 注意这只是一种描述，它只要指导人类进行足够精度的生产实践就够了。它不需要绝对精准，因为语言不能
# 代替物质运行，他只是一种描述手段而已，一旦语言描述的精度不准确，我们可以再次重新描述。

# 这就像连续利率假设一样：利率的本源定义是 r =（Return-Cost）/ Cost; 
# 也就是一段时期内以Cost 为基准，去量化单位去衡量 获利能力（Return-Cost）大小的度量。
# 问题来了，这个`一段时期` 里的， 根据实际环境的差异：生产经营  中 是各不相同的，
#  比如 东北一年一熟，河南一年两熟， 湖南 一年三熟， 海南一年四熟, 即 生产周期各不相同，是一种不可避免的客观现实。
# 
# 从金融角度而言， 如果 需要用一种 统一的方式 去 对 资产（价值创造的物质载体）进行 评估（描述），那就势必需要引入一种 连续概念
# 也就是，如同人民币的元一样，引入一种的基本价值单元： 增值速率单元或者说单位，我们记它为：年利率 Yr 。
# 然后定义 一年一熟 的资产就是 Yr , 一年两熟（1+Yr/2)^2-1,一年n熟（1+Yr/n)^n-1, 这也就是 连续负利率的的 提出的依据。
# 之所以 ，用 Yr/n 来表示，就是说 不管你一年包括几次价值周期（1,2,4,甚至0.5，0.1，0.5, 1/3 也可以）这是差异，
# 重点来了：对于第一个周期而言，大家的的利率始终是是Yr/n, 而这是所有不同复利周期中共享的共同性。
#
# 找到共享的子集，剩下的就是叙述的技巧，或者说形式化的表达语言&规则 即数学。
# 这是一种描述手法上的问题： 周期越小，频率就越快, 相应的扩大再生产的次数就越多. 
# 若才用 Yr/n 作为 `计量连续` 的 粒子点，各种周期的资产价格， 就都可以采用同样的基准利率去Yr衡量了。
# 我们说：连续 赋予一种 囊括了 在诸多规模，量变大小与速率， 下的一种统一的 `描述手段&概念`。
#
# 自然或者说非人工是不讲逻辑的，是白噪声一样的 布朗运动，是没有趋势，周期&节律性的 `粒子&能量` 之冲击下的布朗运动。即：
#   自然，是无秩序，无组织，无规律，无目的。反之则是 非自然。而，
#   非自然，就一定是与自然对立的，有秩序，有组织，有规律，有目的。

# 平滑作为一种 有秩序，有组织，有规律，有目的， 显然它是一种非自然，非布朗运动的过程，结果就是必然是一种设计与安排。
# 即平滑是一种规律性的体现。
# 而解析平滑 则是尝试去还原这个规律的作用机理：它（规律）是如何把 布朗运动 转换成 平滑过程的，或者说 
# 规律是如何控制和干预抑制，制约自然。
# 
# 数学上的平滑概念，本质就是一种精细的设计（刻画），平滑是一种对不平滑即天然的加工和组织。
# 我们认为任何平滑都蕴含着某种待为解释的目的和意图，换句话说 就是 存在与其相关的 控制过程的。
# 
# 平滑的连续代表了某种有意的（主观目的）组织与安排，于是，理性的行为必然表现出一种连续，连贯的序列结构。
# 也就是，用因果逻辑的首尾串联，而构造出的一种 连贯过程。

# 这种连贯是一种 序列的生成系统， 是一种稳定的系统：
# 简单的说，这是一种 自然的原始 能量信息({et}) => 经过 意识行为个体（系统,  人）的处理 之后 出现的 =>时间序列{xt}。
# 我们则是依据 输入{et} 与 输出的{xt} 序列 ，尝试 推导 并解析 意识行为个体（意识系统）的机制与原理(输入与输出关系描述)：
#
# 通过某些数学手段技巧，如： 差分方程，递延算子，变量（随机过程）函数等，去做一般性，通用性的 概括与表达。
# 即阐明本质与机理，即， 规律性的研究。
#
# 时间序列分析：就是构造一种 目标序列 与  白噪声序列 之间的 映射关系。f: {et} -> {xt} ， 即 f({et})={xt}
# 这是一种 Y等一为f(X) 的序列化方式（即函数Y=f(X))。且 X,Y 都是 一向量化的。
# 解析的办法（拆分方程与代数表达式）去认识，理解 以及 表达这种 行为过程，进而可以获得，去驱动，干预，控制，预测 这种过程的 运行。

# 序列变换函数
map <- function (xs, f=\(x, i) x) sapply(seq_along(xs), \(i) f(xs[i], i))

# 移动平均过程，xs：原始时间逆序的序列数据, thetas 权重系数向量,权重为p阶+1。
ma <- function (xs, thetas) (\(n) map(xs, \(x, t) ifelse(t<n, NA, thetas %*% xs[t:(t-n+1)]))) (length(thetas))

# 任意次绘图
plots <- function(...) { # 带有还原绘图环境的绘图，即不会破坏会话session的绘图环境。
  fs <- list(...) # 提取参数
  op <- par(mfrow=c(length(fs), 1), mar=rep(2, 4)) # 缓存原有的图形参数
  lapply(fs, \(f) f()) # 批量调用绘图
  par(op) # 恢复图形参数
}

# 绘图：MA的思想：序列是一种结构，把独立的杂乱（无逻辑）变得连续和有序（有逻辑）的结构。
(\(xs=rnorm(100) |> rev())  # rev 代表逆序，也就是形成 {xs[t], xs[t-1], xs[t-2], ..., xs[t-p+1], xs[t-p],...}这样的序列。以方便进行差分&递延运算。
  list( # 函数列表 , 随着 theta 的增加,前后相关性有所增加, 曲线变得连贯, 这种连贯就是MA的结构所造成的。
      # 原始数据绘图
      origin= \() xs |> plot(type='b', main="origin"),
      # 移动平均绘图
      ma0.2 =  \() ma(xs,c(1, 0.2)) |> plot(type='b', main='ma0.2'),
      # 移动平均绘图
      ma0.4 =  \() ma(xs,c(1, 0.4, 0.2)) |> plot(type='b', main='ma0.4'),
      # 移动平均绘图
      ma0.8 =  \() ma(xs,c(1, 0.8, 0.6, 0.4, 0.2)) |> plot(type='b', main='ma0.8')
  ) # 函数序列
) () |> do.call(plots, args=_)

# 生成一个时间向量
local({
  from <- strptime('2025-01-01 00:00:00', '%Y-%m-%d %H:%M:%S') # 开始时间
  tms <- \(init, interval, n=10) seq(init, by=interval, length.out=n) # 时间向量
  data.frame ( # 生成时间向量的数据框
    sec1=tms(from,"1 sec"), 
    sec5=tms(from,"5 sec"), 
    min1=tms(from,"1 min"),
    min5=tms(from,"5 min"),
    day1=tms(from,"1 day"),
    day5=tms(from,"5 day"),
    week1=tms(from,"1 week"),
    week5=tms(from,"5 week"),
    month1=tms(from,"1 month"),
    month5=tms(from,"5 month"),
    year1=tms(from,"1 year"),
    year5=tms(from,"5 year")
  )
})

# 生成一个随机序列：序列变量a,b需要通过structure 的 dimnames来进行设置
rnorm(20)|>matrix(ncol=2)|>structure(dimnames=list(NULL,list("a","b"))) |> xts(order.by=as.Date(1:10,origin=Sys.Date()))

# 时间序列的分组统计：随机生成一个100*2的数据矩阵，转换成时间序列xts随后依据，月份名称进行统计
rnorm(200)|>matrix(ncol=2)|>structure(dimnames=list(NULL,list("a","b"))) |> xts(order.by=as.Date(1:100,origin=Sys.Date())) |> 
  aggregate(by=partial(substr,start=6,stop=7), sum) #  按照月份名称进行统计

# 区间分组
period.apply(1:10,c(0,4,10),paste0,collapse="-")
