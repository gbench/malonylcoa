# 序列是一种结构：一种蕴含在枚举&罗列表达形式下的过程结构（处理&运行）。
#
# 这种过程结构会把白噪声rnorm(n,mu,sigma)这样的毫无组织&规律的能量冲击{et}，给转换成一种连续&平滑的
# 即富有因果逻辑的结构f({et})，即连续就是结构,它是可以用一种规则表达式f进行解析，用有限次的初等运算给予
# 模拟&复制或是表达的。

# 我们认为：平滑是逻辑的形式结构，平滑就是逻辑（构建&描述事物的规则&方法），逻辑就是平滑，A->B->C-> ...  
# 这是一种无限的量变与质变的演化过程。
# 之所以，没有跳跃，没有出现倒退，那是因为： 存在的 某种耗费额外能量 的生命（意识）过程对其进行维持或者说管理。
#
# 思考一个问题：连续是一种无穷可分的概念，数学与物理的本质区别就是 数学的 的 语言性，物理本质 则是一种 现象的本质描述
# 观念如同单词是一种词法记号，就像 用语言去描述世界一样，想法 或者说 思维观念 其 载体 就是这些 观念或者说 思维概念 的记号
# 我们可以 有限的 文字符号&记录规则 去表达 过去现在与未来，其根本逻辑 语言 主观与抽象性。连续是一种时空意义上的存在抽象
# 它为我们提供一种，囊括了未来预言的以现在认知去理解表达 思维工具。比如：假设目前，我们的科学技术 可以识别的最小粒子半径
# 是1e-10; 100年后，可以识别的最小粒子是半径 是 1e-100， 一千年后是 1e-1000, 请问 从 语言思维描述上对于 粒子的半径需要如何
# 描述？显然就是 给出 一个固定的符号r代表抽象概念（过去，现在，与未来），然后设置一个动态的范围比如 r in Real 即半径属于实数
# 然后 用连续性对其进行描述，注意这只是一种描述，只要指导人类进行足够精度的生产实践就够了。他不需要绝对精准，因为语言不能
# 代替物质运行，他只是一种描述手段而已，一旦语言描述的精度不准确，我们可以再次重新描述。这就像连续利率假设一样
# 利率的本源定义是 r =（Return-Cost）/ Cost; 也就是一段时期内以Cost 为基准量化单位去衡量 获利能力（Return-Cost）大小的度量。
# 问题来了，这个一段时期，在生产经营中 是各不相同的，比如 东北一年一熟，河南一年两熟， 湖南 一年三熟， 海南一年四熟。
# 生产周期各不相同，从金融而言 如果用一种 统一的方式 去 资产（价值创造的物质载体）进行 评估（描述）就势必需要引入一种连续
# 概念也就是，如同人民币的元一样，引入基本价值单元，增值速率单元或者说单位，年利率 Yr ，然后 一年一熟 的资产就是 Yr , 
# 一年两熟（1+Yr/2)^2-1,一年n熟（1+Yr/n)^n-1, 这也就是 连续负利率的的 提出的依据。子所以 Yr/n 表示不管你一年几次价值周期，
# 对于第一个周期而言，大家的的利率始终是是Yr/n,则就是所有不同复利周期中共享的共同性，找到共享的子集，剩下的就是叙述技巧即数学
# 的描述手法上的问题大了，由于就是周期越小，频率就越快,扩大再生产的次数就越多. 这样一Yr/n 作为计量连续的粒子点，各种周期的资产价格
# 就都可以采用同样的基准利率Yr衡量了。连续 赋予一种 囊括了 诸多规模及量变大小与速率下的一种统一的描述手段&概念。
#
# 自然或者说非人工是不讲逻辑的，是白噪声一样的 布朗运动，是没有趋势，周期&节律性的粒子&能量冲击下的布朗运动。
# 即自然就是无秩序，无组织，无规律，无目的。反之 非自然，那就一定是一种 有秩序，有组织，有规律，有目的。
# 平滑作为一种 有秩序，有组织，有规律，有目的 显然它是一种非自然，非布朗运动的过程，结果就是必然是一种设计与安排。
# 即平滑就是一种规律性的体现，而解析平滑 就是尝试去还原这个规律的作用机理，他是如何把 布朗运动 转换成 平滑过程的。
# 
# 数学上的平滑概念，本质就是一种精细的设计（刻画），平滑是一种对不平滑即天然的加工和组织。
# 我们认为任何平滑都蕴含着某种待为解释的目的和意图，换句话说 就是 存在与其相关的 控制过程的。
# 
# 平滑的连续代表了某种有意的（主观目的）组织与安排，于是理性的行为必然表现在一中连续，连贯的序列结构。
# 也就是有因果逻辑的收尾串联而出的一种 连贯过程，这种连贯是由于 序列的生成 系统是 一种稳定的系统：
# 简单的说，这是一种 ，自然的原始能行信息({et}) =》经过 意识行为个体（系统）处理 而后 出现的 =》时间序列{xt}。
# 我们则是依据 输入{et} 与 输出的{xt} 序列 ，尝试 推导 并解析 意识行为个体（意识系统）的机制与原理：
#
# 通过某些数学手段技巧，如： 差分方程，递延算子，变量（随机过程）函数等，做一般性，通用性的 概括与表达。
# 即阐明本质与机理，也就是 规律性研究。
#
# 时间序列分析：就是构造一种 目标序列 与  白噪声序列 折价映射关系。f: {et} -> {xt} ， 即 f({et})={xt}
# 这是一种 Y=f(X) 的序列化方式。X,Y 都是 一向量化的。
# 解析的办法（拆分方程与代数表达式）去认识，理解 以及 表达这种 行为过程，进而可以获得
# 去驱动，干预，控制，预测 这种过程的 运行。

# 序列变换函数
map <- function (xs, f=\(x, i) x) sapply(seq_along(xs), \(i) f(xs[i], i))

# 移动平均过程，xs：原始时间逆序的序列数据, thetas 权重系数向量,权重为p阶+1。
ma <- function (xs, thetas) (\(n) map(xs, \(x, t) ifelse(t<n, NA, thetas %*% xs[t:(t-n+1)]))) (length(thetas))

# 任意次绘图
plots <- function(...) { # 带有还原绘图环境的绘图，即不会破坏会话session的绘图环境。
  fs <- list(...) # 提取参数
  op <- par(mfrow=c(length(fs), 1), mar=rep(2, 4)) # 缓存原有的图形参数
  lapply(fs, \(f) f()) # 批量调用绘图
  par(op) # 恢复图形参数
}

# 绘图：MA的思想：序列是一种结构，把独立的杂乱（无逻辑）变得连续和有序（有逻辑）的结构。
(\(xs=rnorm(100) |> rev())  # rev 代表逆序，也就是形成 {xs[t], xs[t-1], xs[t-2], ..., xs[t-p+1], xs[t-p],...}这样的序列。以方便进行差分&递延运算。
  list( # 函数列表 , 随着 theta 的增加,前后相关性有所增加, 曲线变得连贯, 这种连贯就是MA的结构所造成的。
      # 原始数据绘图
      origin= \() xs |> plot(type='b', main="origin"),
      # 移动平均绘图
      ma0.2 =  \() ma(xs,c(1, 0.2)) |> plot(type='b', main='ma0.2'),
      # 移动平均绘图
      ma0.4 =  \() ma(xs,c(1, 0.4, 0.2)) |> plot(type='b', main='ma0.4'),
      # 移动平均绘图
      ma0.8 =  \() ma(xs,c(1, 0.8, 0.6, 0.4, 0.2)) |> plot(type='b', main='ma0.8')
  ) # 函数序列
) () |> do.call(plots, args=_)

# 生成一个时间向量
local({
	from <- strptime('2025-01-01 00:00:00', '%Y-%m-%d %H:%M:%S') # 开始时间
	tms <- \(init, interval, n=10) seq(init, by=interval, length.out=n) # 时间向量
	data.frame ( # 生成时间向量的数据框
		sec1=tms(from,"1 sec"), 
		sec5=tms(from,"5 sec"), 
		min1=tms(from,"1 min"),
		min5=tms(from,"5 min"),
		day1=tms(from,"1 day"),
		day5=tms(from,"5 day"),
		week1=tms(from,"1 week"),
		week5=tms(from,"5 week"),
		month1=tms(from,"1 month"),
		month5=tms(from,"5 month"),
		year1=tms(from,"1 year"),
		year5=tms(from,"5 year")
	)
})

# 生成一个随机序列：序列变量a,b需要通过structure 的 dimnames来进行设置
rnorm(20)|>matrix(ncol=2)|>structure(dimnames=list(NULL,list("a","b"))) |> xts(order.by=as.Date(1:10,origin=Sys.Date()))

# 时间序列的分组统计：随机生成一个100*2的数据矩阵，转换成时间序列xts随后依据，月份名称进行统计
rnorm(200)|>matrix(ncol=2)|>structure(dimnames=list(NULL,list("a","b"))) |> xts(order.by=as.Date(1:100,origin=Sys.Date())) |> 
  aggregate(by=partial(substr,start=6,stop=7), sum) #  按照月份名称进行统计

# 区间分组
period.apply(1:10,c(0,4,10),paste0,collapse="-")
