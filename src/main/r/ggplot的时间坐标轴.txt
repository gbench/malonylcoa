我有一段时间序列xts格式的交易数据prices，prices的元素是每个交易日具体到每分钟成交价格，由于交易时间的开盘时间的连续，
prices 的时间索引是不连续的，首先，价格数据只在工作日才存在，其次，每个工作日，只在:
9:00-10:15，10:30-11:30, 13:00-15:00, 21:00-23:00 才进行交易。
请编写使用ggplot绘制出该prices的分时图。需要把各个价格时间进行连续显示，
也就是10:15的下一刻是10:30，11:30的下一刻是13:00，15:00 下一刻21:00，23:00的下一刻是次日的9:00。如果
今日是周一，次日就是本周周二，如果今日是周五，次日是下周一，其余依次类推。
# -------------------------------------------------------------------------------------------------------------------

partition <- \(line, delim=",") line |> strsplit(delim) |> unlist() # 切分
as.datetime <- partial(as.POSIXct, format="%H:%M:%S") # 时间分析
data <- sqlquery("select * from t_ma501_20241209") |> compute_kline() # K 线数据
interval <- "15 min" # 时间间隔
std.breaks <- "09:00:00,10:15:00;10:30:00,11:30:00;13:30:00,15:00:00;20:00:00,23:00:00" |> # 坐标刻度，标准时间刻度
  partition(delim=";") |> # 解析交易时段
  lapply(\(line, ps=compose(as.datetime, partition)(line), .interval=interval) seq(ps[1], ps[2], by=.interval)) |> # 提取交易标记点
  Reduce(c, init=as.POSIXct(character(0)), x=_) # Reduce 需要为init指定由初始类型，如果提供默认c()则会返回long型数据
dfm <- data["T09:00/T23:00"] |> (\(d, idx=index(d)) { # 剔除指定时间端的数据
  d[ ! (idx>as.datetime("15:00:00") & idx<as.datetime("21:00:00")) ]
})() #  数据范围

# 时间绘图
library(tidyverse) # 加载函数库，ggplot2 与 dplyr
ggplot(dfm, aes(seq_along(index(dfm)))) + # 基础数据
  geom_line(aes(y=Close)) + # 收盘价
  scale_x_continuous( # 自定义时间轴
    breaks=\(x) { # 需要保持与ggplot的基础映射x的相同的数据类型
      print(sprintf("breaks:%s(%d)", x, length(x)))
      tp <- c("10:15:00", "11:30:00", "15:00:00") |> as.datetime() # 连接时间点，交易时段的结尾时刻
      breaks <- std.breaks[-match(tp, std.breaks)] # 剔除掉省略掉的时间
      print(sprintf("breaks --> %s(%d)", breaks, length(breaks)))
      match(breaks, index(dfm)) |> na.omit() # 剔除NA值
    }, labels=\(x) { # 坐标id
      print(sprintf("labels:%s(%d)", x, length(x)))
      points <- index(dfm)[x] # 提取时间点数据的时间索引
      # 定义关键时间点
      p1030 <- as.datetime("10:30:00")
      p1330 <- as.datetime("13:30:00")
      p2100 <- as.datetime("21:00:00")
      lbls <- dplyr::case_when( # 时间刻度
         points == p1030 ~ "10:15/30", # 上午盘的时间交接点
         points == p1330 ~ "11/13:30:00", # 下午盘的时间交接点
         minute(points) == 0 & points == p2100 ~ "15/21:00", # 晚盘的时间交接点
         minute(points) == 0 ~ format(points, "%H:00"), # 默认整点时刻
         TRUE ~ sprintf("%02d", minute(points)) # 默认非整点时刻
      ) # 时间刻度
      print(sprintf("labels --> %s(%d)", lbls, length(lbls)))
      lbls
    }, limits=\(x) { # 刻度区间
      print(sprintf("limits:%s(%d)", x, length(x)))
      x
    }) + # 自定义时间轴
  labs(x = "时间", y = "收盘价格", title = "价格线图") # 坐标轴名称

# -------------------------------------------------------------------------------------------------------------------

partition <- \(line, delim=",") line |> strsplit(delim) |> unlist() # 切分
as.datetime <- partial(as.POSIXct, format="%H:%M:%S") # 时间分析
data <- sqlquery("select * from t_ma505_20241213") # 检索数据
data$UpdateTime <- as.datetime (data$UpdateTime) # 解析时间

# 时间段分割
# "09:00:00,10:15:00;10:30:00,11:30:00;13:30:00,15:00:00;20:00:00,23:00:00" |>
breaks <- "09:00:00,10:15:00;10:30:00,11:30:00" |>
  partition(delim=";") |> # 解析交易时段
  lapply(\(line, ps=compose(as.datetime, partition)(line), interval="15 min") seq(ps[1], ps[2], by=interval)) |> # 提取交易标记点
  Reduce(c, init=as.POSIXct(character(0)), x=_) # Reduce 需要为init指定由初始类型，如果提供默认c()则会返回long型数据
labels <- ifelse(minute(breaks)==0, format(breaks, "%H:00"), sprintf("%02d", minute(breaks)))

# 时间绘图
ggplot(data, aes(UpdateTime, LastPrice)) + geom_line() +
  scale_x_datetime(breaks=breaks, limits=range(breaks), labels=labels)
# -------------------------------------------------------------------------------------------------------------------

# 版本1
local({
  # datasource of {host:00, db:ctp, port:3371}
  n <- 10 # 分割点
  ds00ctp <- partial(sqlquery, dbname="ctp", port=3371, host="127.0.0.1") # 数据查询方法之定义数据源:ds{host}{db}
  curtbl <- "t_rb2601_20251114" # 成交数据tickdata的数据表名，current table 当前表
  "select * from %s" |> sprintf(curtbl) |> ds00ctp() %>% with( # 打开成交数据&暴露元素，方便直接引用，{Id:序列索引，LastPrice:成交价格}
    ggplot(., aes(Id, LastPrice)) + geom_point(alpha=0.01) + geom_smooth() +
      geom_hline(yintercept=2*(1:3-2)*sd(LastPrice)+mean(LastPrice), # 均线与2倍数标准差
        linewidth=c(1.5, 1, 1.5), color=c("darkred", "gray", "red")) + with(lm(LastPrice~Id), # 趋势回归的成交价格vs序列Id索引模型
      geom_abline(slope=coefficients[2], intercept=coefficients[1], linewidth=1.5, color="purple")) + # 趋势线
      scale_x_continuous(# 自定义时间轴 将 对应的Id值转换成时间刻度
        breaks=\(xs) seq(xs[1], xs[2], length.out=n) |> round(0), # 范围xs中的n个均分点,考虑scales::extended_breaks原因，首尾两Id无效
        labels=\(bs, index=match(bs[bs %in% Id], Id)) UpdateTime[append(range(seq(Id)), index, 1)] # 时间刻度
      ) # scale_x_continuous
  ) # with 打开成交数据&暴露元素
})

# 版本2：检测分点bs与Id之间最近的距离：sapply(bs, \(x) which.min(abs(Id - x)))
local({
  # datasource of {host:00, db:ctp, port:3371}
  n <- 10 # 分割点
  ds00ctp <- partial(sqlquery, dbname="ctp", port=3371, host="127.0.0.1") # 数据查询方法之定义数据源:ds{host}{db}
  curtbl <- "t_rb2601_20251114" # 成交数据tickdata的数据表名，current table 当前表
  "select * from %s" |> sprintf(curtbl) |> ds00ctp() %>% with( # 打开成交数据&暴露元素，方便直接引用，{Id:序列索引，LastPrice:成交价格}
    ggplot(., aes(Id, LastPrice)) + geom_point(alpha=0.01) + geom_smooth() +
      geom_hline(yintercept=2*(1:3-2)*sd(LastPrice)+mean(LastPrice), # 均线与2倍数标准差
        linewidth=c(1.5, 1, 1.5), color=c("darkred", "gray", "red")) + with(lm(LastPrice~Id), # 趋势回归的成交价格vs序列Id索引模型
      geom_abline(slope=coefficients[2], intercept=coefficients[1], linewidth=1.5, color="purple")) + # 趋势线
      scale_x_continuous(# 自定义时间轴 将 对应的Id值转换成时间刻度
        breaks=\(xs) seq(xs[1], xs[2], length.out=n) |> round(0), # 范围xs中的n个均分点,考虑scales::extended_breaks原因，首尾两Id无效
        # 对于不在Id中的断点，使用findInterval找到最近的位置。并将结果为0的情况转换为1
        # labels=\(bs,  xs=match(bs, Id), indices=ifelse(is.na(xs), findInterval(bs, Id), xs)) UpdateTime[ifelse(0==indices,1, indices)] # 时间刻度
        # 手动检测：通过which.min(abs(Id - x)) 找到最接近分点x的Id，并获对应于此Id记录所在整个tickdata中的索引偏移
        labels=\(bs) UpdateTime[sapply(bs, \(x) which.min(abs(Id - x)))] # 翻译成时间刻度
      ) # scale_x_continuous
  ) # with 打开成交数据&暴露元素
})

# 版本3：直接均分Id索引 breaks=\(xs) seq(min(Id), max(Id), length.out=n) 
# 注意：scale_x_continuous(breaks=\(xs) seq(1, length(Id), length.out=n), labels=\(xs) UpdateTime[xs]) # 这是错的  !
# 因为 当Id不是从1开始的时候，breaks就不是Id（坐标轴的aes图型映射）的有效值范围，因此它就是不是有效分点, labels收不到非法breaks
# 即 ggplot会把非法breaks给强制转换成NA，进而坐标轴为空白！
local({
  n <- 10 # 时间分割点数量
  # datasource of {host:00, db:ctp, port:3371}
  ds00ctp <- partial(sqlquery, dbname="ctp", port=3371, host="127.0.0.1") # 数据查询方法之定义数据源:ds{host}{db}
  curtbl <- "t_rb2601_20251114" # 成交数据tickdata的数据表名，current table 当前表
  "select * from %s" |> sprintf(curtbl) |> ds00ctp() %>% with( # 打开成交数据&暴露元素以方便直接引用：{Id:序列索引，LastPrice:成交价格}
    ggplot(., aes(Id, LastPrice)) + geom_point(alpha=0.01) + geom_smooth() +
      geom_hline(yintercept=2*(1:3-2)*sd(LastPrice)+mean(LastPrice), # 均线与2倍数标准差
        linewidth=c(1.5, 1, 1.5), color=c("darkred", "gray", "red")) + with(lm(LastPrice~Id), # 趋势回归的成交价格vs序列Id索引模型
      geom_abline(slope=coefficients[2], intercept=coefficients[1], linewidth=1.5, color="purple")) + # 绘制趋势线
      scale_x_continuous(breaks=\(xs) seq(min(Id), max(Id), length.out=n), labels=\(xs) UpdateTime[xs-min(Id)+1]) # 索引刻度转时间标签
  ) # with 打开成交数据&暴露元素
})