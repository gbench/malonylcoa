# --------------------------------------------------------------------------------------------------------------
# 分组就是在一个总体之中，从各个个体之中提取（抽象出）相应共性，并依据共性的不同进行进行相应的分类
# 每个分类就是对应的分组号（总体的成分结构），所以 分组 的分支就是 对 总体进行 分解，每个分组就是一种
# 相对与总体的部分的概念，递归的分组算法， 本质就是一种 Treeable的结构化思维,层级化,条理化的逻辑思维
# 所以 分组 是 数据分析的关键，分组的难度在于如何以一种创造性的方式对总体(数据)进行联想、关联出 蕴含在
# 思维深处（社会，环境，经济文化，文化，经验）中 相关的 价值&意义 的潜在 概念与逻辑（理论），并给出
# 形式化定义，即 创造&应用实际概念， 这就是 分析的结构性逻辑本质。
# --------------------------------------------------------------------------------------------------------------

# 因子分组
(\(x, n) { # gl(n, length(x)) <=> rep(seq(n), rep(length(x), n)) <=> 数据分为n组，每组中包含元素length(x)个！
  rep(x, n) |> split(gl(n, length(x))) |> expand.grid() |> print()
  print("--------------------------------------------------------")
  rep(x, n) |> split(rep(seq(n), rep(length(x), n))) |> expand.grid() |> print()
}) (c(-1, 0, 1), 3)

# 读取数据
data <- read.csv(file.choose())

# 提取最新的价格数据，10天一个分组
tail(data,100) |> split((\(x) (x-1)%/%10+1)(1:100))

# 提取最新的价格数据，10天一个分组
tail(data,100) |> split(rep(1:10, rep(10,10)))

# 提取收盘价格
tail(data,100) |> split(rep(1:10, rep(10,10))) |> sapply(\(p) p['c']) 

# 任意次绘图
plots <- function(...) {
  fs <- list(...) # 提取参数
  op <- par(mfrow=c(length(fs), 1), mar=rep(2, 4)) # 缓存原有的图形参数
  lapply(fs, \(f) f()) # 批量调用绘图
  par(op) # 恢复图形参数
}

# melt 技巧: nrow(x) 行数目, length(x) 列数目
# gl(nrow(x), 1, nrow(x)*length(x), labels=row.names(x)) 把x的行名称每行复制length(x)次数生成长度nrow(x)*length(x)的向量
( \(x) gl(nrow(x), 1, nrow(x)*length(x), labels=row.names(x)) |> cbind(id=_, stack(x)) ) (mtcars)

# 收盘价格绘图
tail(data,100) |> split(rep(1:10,rep(10,10))) |> lapply(\(p) \() plot(p[['c']])) |> tail(2) |> do.call(plots,args=_)

# Points GroupNumbers 计算一个点序列ps的gn阶descartes product
# ps : points 基础点集向量
# gn : groups numer 分组数量
# rep(ps, gn) 构建线性点集序列；rep( seq(gn), rep(length(ps), gn) ) ：构建分组序列，seq(gn) 分组标号序列；length(ps) 各个分组的数据长度,
# 数据笛卡尔积， ps: points点集合 gn: group numer 分组阶数 
pgn <- function(ps=1:3, gn=length(ps)) rep(ps, gn) |> split( rep(paste0("x", seq(gn)), rep(length(ps), gn)) ) |> expand.grid()
# 三叉树模式:-1下跌,0不变,1增长
pgn(ps=-1:1)
#  三叉树模式：2阶
pgn(ps=-1:1, gn=2)

# 应用实例-投资5期的3叉树的收益情况收益分布：pmap_dbl(.,sum) 计算收益， group_by(sum 收益分组， summarise(n())  统计收益频数
library(tidyverse) # 导入数据处理框架 tidyverse，即 pmap, %>%, group_by, summarise, n() 等函数所在的包环境
pgn(-1:1, 5) %>% mutate(sum=pmap_dbl(.,sum)) |> group_by(sum) |> summarise(n()) %>% { # 注意, 对象是一个tibble : 'sum', 'n()'
  plot( ., type="b", # 绘制点线图
        xlab="收益情况", ylab="分布频数",
        main="三叉树模型-收益分布", sub="投资5期收益分布") # 绘图
  apply( ., 1, \(e) text(e[1], e[2], labels= paste0(e, collapse=" , ")) ) # 绘制坐标值：收益与频数
}

# 纯R语言实现
pgn(-1:1, 5) |> (\(x) transform(x, sum=apply(x, 1, sum))) () |> (\(x) split(x, x$sum)) () |> lapply(nrow) |>( \(y, x=names(y)) { # 数量频数统计, y是list
  plot(x, y, type="b", # 绘制点线图
        xlab="收益情况", ylab="分布频数",
        main="三叉树模型-收益分布", sub="投资5期收益分布") # 绘图
  p <- (\(nums=unlist(y), v=nums/sum(nums)) paste0(round(v*100, 2), "%")) () # percent 百分比
  text(x, y, labels=paste(x, y, p, sep=" , "))  # 绘制坐标值：收益与频数
}) ()

# iris-分组统计
split(iris[, -5], iris$Species) |> # 中心点，依据物种进行分类并获取对应分类中心点(维度坐标分组的均值向量）
  lapply(partial(apply, MARGIN=2, FUN=mean)) |> # 分组计算每种物种分类的均值
  Reduce(rbind, init=data.frame(), x=_) |> # 把各个分组进行连接，参见haskell的foldl
  transform(Species=paste0(rep("centroids", compose(length, levels)(iris$Species)), "-", levels(iris$Species)) ) |> 
  structure(names=names(iris)) 

# iris-分组统计
aggregate(x=cbind(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) ~ Species, data=iris, FUN=mean)

# -----------------------------------------------------------------------------------------------------------------
# 矩阵的行列分组, row, col 的使用。
# -----------------------------------------------------------------------------------------------------------------
# 矩阵的本质是连续的向量(即与向量没有本质不同），只是带有了维度信息而已 
> m0 <- 1:10 |> structure(dim=c(2, 5)); m0
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10
> row(m0)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    2    2    2    2    2
> col(m0)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
> attributes(m0)
$dim
[1] 2 5

# 把一个矩阵按照行或者列进行分组
m <- matrix(1:10, ncol=5)

# m数据的建结构
> m <- matrix(1:10, ncol=5); m
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

#对矩阵按照行进行分组
split(m, row(m))

> split(m, row(m))
$`1`
[1] 1 3 5 7 9

$`2`
[1]  2  4  6  8 10

#对矩阵按照列进行分组
split(m, col(m))

> #对矩阵按照列进行分组
> split(m, col(m))
$`1`
[1] 1 2

$`2`
[1] 3 4

$`3`
[1] 5 6

$`4`
[1] 7 8

$`5`
[1]  9 10

# -----------------------------------------------------------------------------------------------------------------
# dplyr 的使用技巧
# -----------------------------------------------------------------------------------------------------------------
library(dplyr)

# 准备数据："%>%"与"|>"的一个关键区别就是"%>%"的"."可以深入嵌套，但"|>"的"_"只能位于第一层。大量使用"|>"是因为它输入简单"少一个字符"而这对于交互式极为关键
dfm <- (\(x, n) rep(x, n) |> split(gl(n, length(x))) |> expand.grid() %>% structure(names=paste0("x", 1:dim(.)[2])) |> mutate(LA=lag(x2), LE=lead(x2))) (1:3, 2) 

# 数据分组：按照行分组
dfm %>% group_by(k=gl(dim(.)[1], 1)) |> mutate(s=paste(x1, x2, LA, LE, k, sep="=>")) # 保持了分组结构标记
dfm %>% group_by(k=gl(dim(.)[1], 1)) |> mutate(s=paste(x1, x2, LA, LE, k, sep="=>")) |> ungroup() # 消除了分组结构标记

# 行计算：rowwise() 相当于 group_by(k=gl(dim(.)[1], 1)) 的语法糖
dfm %>% group_by(k=gl(dim(.)[1], 1)) |> mutate(s=sum(x1, x2)) |> ungroup()
# 行计算
dfm %>% rowwise() |> mutate(s=sum(x1, x2))

# 分组排序
dfm |> group_by(x1) |> arrange(desc(x2))
dfm |> group_by(x1) |> arrange(desc(x2), by_group=T)
dfm |> arrange(desc(x1))

# 行选择
dfm |> filter(x1>1)
dfm |> filter(x1>1, x2==1)

# 列选择
dfm |> select(LA, LE)
dfm |> filter(x1>1, x2==1) |> select(LA, LE)

# -----------------------------------------------------------------------------------------------------------------
# table分组计数技巧
# -----------------------------------------------------------------------------------------------------------------
local({ # 期货成交价格的能量能量分布
# tably依赖库janitor以及相关操作函数的依赖
"purrr,dplyr,janitor,snakecase,RMySQL" |> strsplit(",") |> unlist() |> 
    lapply(\(pkg) if(!require(pkg, character.only = T)) {install.packages(pkg); require(pkg)} else T) 

# datasource of {host:10, db:ctp, port:3371}
ds10ctp <- partial(sqlquery, dbname="ctp", port=3371, host="192.168.1.10") # 数据查询方法
curtbl <- "t_rb2601_20251113" # 数据表名，current table 当前表

# 数据SQL，LastPrice：最新成交价格；Volume：日内累计的撮合成交数量
sql <- "select Id, LastPrice, Volume, Volume - lag(Volume) over(order by Id) Vol, UpdateTime from %s" |> sprintf(curtbl) # 数据SQL
nlevel <- 3 # （撮合）成交量的区间分组数量

# table 交叉表的统计计数（频数/频率其实就是定位数据的位置分布坐标，创造出"值是多少,值在哪里/概率"的数据分布统计），把第一行去除因为Vol的第一项为NA
ds10ctp(sql)[-1, ] |> mutate(Level=cut(Vol, nlevel)) |> select(LastPrice, Level) |> # 价格与成交量关系数据
   table() |> prop.table() |> addmargins() |> # 计算百分比并添加margin统计
   (\(x) {attr(x, "dimnames") <- attr(x, "dimnames") |> within(Level <- gsub("e\\+03", "K", Level)); x}) () |> round(3) # 标题美化并保留3位小数

# adjust 格式，把第一行去除因为Vol的第一项为NA
ds10ctp(sql)[-1, ] |> mutate(Level=cut(Vol, nlevel)) |> tabyl(LastPrice, Level) |> # 价格与成交量关系数据
  adorn_percentages("row") |> adorn_pct_formatting(digits=1) |> # 价格在具体成交量区间上的分布
  (\(x) {names(x) <- gsub(x=names(x), "e\\+03", "K"); x}) ()
})

# -----------------------------------------------------------------------------------------------------------------
# 分组实用函数
# -----------------------------------------------------------------------------------------------------------------
cut函数介绍：
cut 函数的核心功能是将一个数值型向量按照指定的“断点”切割成若干个区间，并将每个数值映射到对应的区间，返回一个因子。
这在数据分析中非常有用，例如：
数据分组：将年龄（连续）分组为“青年”、“中年”、“老年”。
制作频数分布表：统计不同收入区间的人数。
满足模型需求：某些机器学习算法需要分类变量而非连续变量。
基本语法：cut(x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, ...)
参数说明：
  x: 分析处理对象，要被切割的数值型向量。
  breaks: 断点结构，定义切割区间的断点有两种方式
    断点向量：数值向量（如 c(0, 18, 65, 100)），明确指定每个区间的边界。
    断点数量：单个整数（如 5），表示将数据范围分成大致相等的区间数。实际区间数可能比这个数少1。
  labels: 区间标签，用于标识每个区间的标签。它是一个字符向量。
    默认值：NULL，则 R 会自动生成像 (a, b] 这样的区间表示作为标签。
    自定义：长度必须等于区间的数量(length(breaks)-1)的自定义字符串向量（如 c(“青年”, “中年”, “老年”)）。
  区间造型参数：T造型 ( ] - 左边开放，右边闭合。F造型 [ ) - 左边闭合，右边开放；记忆办法：字符"F"与"["相似！
    include.lowest: 端点区间造型是否包含包含breaks结构中的断点，T包含，F不包含
    right: 区间造型参数，逻辑值默认为T，中间区间(头&尾区间的剩余区间）是T造型的(]还是F造型的[)。 默认是T造型的(]的区间形式！

#  分析对象（数据）
xs <- 1:10 

# 用断点数量方式定义断点
breaks <- 3 # 用断点数量的方式定义断点结构
cut(xs, breaks) # 用断点数量方式定义断点

# cut返回的Levels: (0.991,4] (4,7] (7,10] 就是breaks结构
>
 [1] (0.991,4] (0.991,4] (0.991,4] (0.991,4] (4,7]     (4,7]     (4,7]    
 [8] (7,10]    (7,10]    (7,10]   
Levels: (0.991,4] (4,7] (7,10]

# 用断点向量（明细结构）的方式定义断点结构
breaks <- c(0, 4, 8,11) # 用断点向量（明细结构）的方式定义断点结构
cut(xs, breaks)
>
 [1] (0,4]  (0,4]  (0,4]  (0,4]  (4,8]  (4,8]  (4,8]  (4,8]  (8,11] (8,11]
Levels: (0,4] (4,8] (8,11]

# cut测试FT：(0,4] (4,8] (8,10]
> cut(xs, c(0,4, 8,10), include.lowest=F, right=T)
 [1] (0,4]  (0,4]  (0,4]  (0,4]  (4,8]  (4,8]  (4,8]  (4,8]  (8,10] (8,10]
Levels: (0,4] (4,8] (8,10]

# 注意，用断点向量 定义断点结构式，range(breaks)   要覆盖range(x)否则会出现NA
# cut测试FF：[0,4) [4,8) [8,10)
> cut(xs, c(0,4, 8,10), include.lowest=F, right=F)
 [1] [0,4)  [0,4)  [0,4)  [4,8)  [4,8)  [4,8)  [4,8)  [8,10) [8,10) <NA>  
Levels: [0,4) [4,8) [8,10)

# cut测试FF：[0,4] (4,8] (8,10]
> cut(xs, c(0,4, 8,10), include.lowest=T, right=T)
 [1] [0,4]  [0,4]  [0,4]  [0,4]  (4,8]  (4,8]  (4,8]  (4,8]  (8,10] (8,10]
Levels: [0,4] (4,8] (8,10]

# 注意，注意include.lowest把breaks的边界点给覆盖了
# cut测试TF：[0,4) [4,8) [8,10]
> cut(xs, c(0,4, 8,10), include.lowest=T, right=F)
 [1] [0,4)  [0,4)  [0,4)  [4,8)  [4,8)  [4,8)  [4,8)  [8,10] [8,10] [8,10]
Levels: [0,4) [4,8) [8,10]

# -----------------------------------------------------------------------------------------------------------------
# 区间分割
> cut(1:10, 0:10)
 [1] (0,1]  (1,2]  (2,3]  (3,4]  (4,5]  (5,6]  (6,7]  (7,8]  (8,9]  (9,10]
Levels: (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]

# 区间匹配，区间适配
> findInterval(1:10, cut(1:10, 0:10))
 [1]  1  2  3  4  5  6  7  8  9 10

# --------------------
> xs <-1:10; xs;
 [1]  1  2  3  4  5  6  7  8  9 10
> bins <- cut(xs, 0:10); bins;
 [1] (0,1]  (1,2]  (2,3]  (3,4]  (4,5]  (5,6]  (6,7]  (7,8]  (8,9]  (9,10]
Levels: (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]
> indices <- findInterval(xs, bins); indices;
 [1]  1  2  3  4  5  6  7  8  9 10
> bins[indices]
 [1] (0,1]  (1,2]  (2,3]  (3,4]  (4,5]  (5,6]  (6,7]  (7,8]  (8,9]  (9,10]
Levels: (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]

# --------------------
> xs <-1:10; xs;
 [1]  1  2  3  4  5  6  7  8  9 10
> bins <- cut(xs, 0:10, right=F); bins;
 [1] [1,2)  [2,3)  [3,4)  [4,5)  [5,6)  [6,7)  [7,8)  [8,9)  [9,10) <NA>  
Levels: [0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8) [8,9) [9,10)
> indices <- findInterval(xs, bins); indices;
Error in findInterval(xs, bins) : 
  'vec' must be sorted non-decreasingly and not contain NAs
> bins[indices]
 [1] [1,2)  [2,3)  [3,4)  [4,5)  [5,6)  [6,7)  [7,8)  [8,9)  [9,10) <NA>  
Levels: [0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8) [8,9) [9,10)
> 
# --------------------



