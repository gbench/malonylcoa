#' 
#' 二分法求值：过程方式, 缓存fa, 减少一次调用。
#' 注意，不要小看这减少的一次调用，对性能影响是很大的，详见 后面的性能分析。
#'
#' @param f 数值方程， 比如  \(x) x^2 - 4
#' @param a 数值方程， 区间开始位置，默认为0
#' @param b 数值方程， 结束位置，默认为1
#' @param eps 误差大小 大于零的小数, 默认为1e-10
#' @return f(x)==0 的方程根
bisect <- function (f, a=0, b=1, eps=1e-10) {
  (\(fa) { # 缓存f(a)的计算结果
    if (fa*f(b)>0) NA # 相同符号则放弃运算, 结果不可用 
    else if (abs(f(a))<eps) a # 端点值就是方程解
    else if (abs(f(b))<eps) b # 端点值就是方程解
    else { # a, b 位于 root 异侧
      repeat { # 以持续缩短根值root区间[a,b]的长度的方式（二分法）, 逐渐优化&定位有效根值root位置，直到该区间长度进入精度(误差容许)范围。
        assign('c', (a+b)/2) #  指定c为 a 与 b 的中心点, 不采用 c <- (a+b)/2的原因是为了强调：这是用一个符号'c'绑定值(a+b)/2；'c' 可以理解为[a,b]的中点位置的值引用
        if(abs(assign('fc', f(c)))<eps || abs(b-a)<eps) break # 直接获得精确解 或者  持续计算直到b与a之间的距离小于误差限制eps，终止计算
        assign('flag', fa*fc<0) # fa与a,b的中心点c处的f值fc是否位于f与x轴交点即root的两旁：true: a,c 异侧，false: a,c同侧.
        if(!flag) assign('fa', fc) # a, c同侧则需要更新fa，这样就可以保证 fa与f(b)是始终是异号，进而a,b区间必然包含有root值
        assign(ifelse(flag, 'b', 'a'), c, parent.frame()) # 根据flag状态将中心点c配置到下一阶段的初始值位置:a,c 同侧c更新a; a,c异侧c更新b;以保证新的a,b区间始终包含root
      } # repeat
      c # 返回 a 与 b 的中心点
    } # if
  }) (f(a)) # 计算f(a) 并将结果缓存到fa
}

#' 净现值函数
#'
#' @param rate:内部收益率(折现利率)
#' @param pmts:支付现金流(负值)
#' @param price:资产现价(正值)
#' @return 净现值:将支付现金流pmts按照利率rate进行折现去冲抵资产现价price所产生的余额,当price与元组(pmts, rate)相匹配的时候,npv为0
#'               反过来也可以定义内部收益率(IRR) 为: 调整rate,使得price与元组(pmts, rate)相抵即npv为0时的折现利率。
npv <- function (rate, pmts, price) sum(pmts*(1+rate)^-(1:length(pmts))) + price

#' 等额本息支付类型的金融工具（债券,按揭贷款等）的 结构拆解(分解成一组折现债券)
#'
#' @param ps 等额本息的支付序列
#' @param price 金融工具价格(当前价格）
#' @return 一组折现债券
strips <- function (ps,  price=10000) {
  n <- length(ps) # 支付序列长度
  pmts <- ps #  支付序列(债券面值)
  rate <- bisect(\(r) npv(r, -pmts, price)) # 内部收益率(折现利率）
  pvs <- pmts * (1+rate)^-seq(n) # 现值(本金)序列(现值价格)
  interest <- pmts - pvs # 利息序列:支付与现值之间的差额(到期利息收益)
  data.frame(pvs, pmts, rate, interest) # 一组折现债券（每行一个折价债券，pvs:现值价格，pmts:面值，rate:折现利率，interest:到期利息收益, row.names: 到期期限）
}

# 购买1万元现金资产，以日利息0.5元的融资费用，产生的月度支付序列: (\(n=12) rep((10000+30*0.5*n)/n, n))()
(\(n=12) rep((10000+30*0.5*n)/n, n))() |> strips()

>
        pvs     pmts        rate  interest
1  846.0023 848.3333 0.002755332  2.331017
2  843.6777 848.3333 0.002755332  4.655629
3  841.3595 848.3333 0.002755332  6.973854
4  839.0476 848.3333 0.002755332  9.285708
5  836.7421 848.3333 0.002755332 11.591210
6  834.4430 848.3333 0.002755332 13.890378
7  832.1501 848.3333 0.002755332 16.183227
8  829.8636 848.3333 0.002755332 18.469777
9  827.5833 848.3333 0.002755332 20.750043
10 825.3093 848.3333 0.002755332 23.024044
11 823.0415 848.3333 0.002755332 25.291797
12 820.7800 848.3333 0.002755332 27.553318

# 对列向量组，按照列，进行累计汇总
(\(n=12) rep((10000+30*0.5*n)/n, n))() |> strips() |> apply(2, sum)

>
         pvs         pmts         rate     interest 
1.000000e+04 1.018000e+04 3.306398e-02 1.800000e+02

