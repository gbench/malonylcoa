# ----------------------------------------------------------------------------------------------------------------
# 数据库操作的使用示例
# 示例数据库为:  CTP 交易的TickData , 以 数据表 t_{合约代码的小写}_{日期时间戳} 的形式 存储于数据库
# 如 t_ma505_20241219, t_rb2505_20241219. 需要注意表名的合约代码采用小写表示，对于甲醇25年5月合约的代码是其实是M505而非ma505
# 表数据结构：t_ma505_20241219 数据结构示例：
# > sqlquery("select * from t_ma505_20241219 limit 1") |> toJSON()
# [{"Id":1,"Instrument":"MA505","LastPrice":2601,"AskPrice":2601,"BidPrice":2600,"AskVolume":17,"BidVolume":667,"UpdateTime":"10:44:45","UpdateMillisec":500,"Volume":400590,"OpenInterest":744350,"AveragePrice":2609,"UpperLimitPrice":2785,"LowerLimitPrice":2419,"PreOpenInterest":709864,"PyctpCreateTime":"2024-12-19 10:44:45.767639"}] 
# 
# ----------------------------------------------------------------------------------------------------------------

library(RMySQL) # MySQL 数据库驱动所在库
library(dplyr) # coalesce 函数所在库
library(reshape2) # melt 函数所在库
library(ggplot2) # ggplot 函数所在库
library(jsonlite) # toJSON() 函数所在库
library(purrr) # partial 函数所在库
library(quantmod) # chartSeries 函数所在库
library(xts) # xts 函数所在库
# library(data.table) # rbindlist,fwrite,fread 函数所在库

# 本地环境设置: 通常需要在 R.home()/etc/Rprofile.site 文件中进行全局配置！
options( # sqlquery的数据库参数预先设置
#  sqlquery.drv=MySQL(),
  sqlquery.host="localhost", 
  sqlquery.user="root", 
  sqlquery.password="123456", 
  sqlquery.port=3371, 
  sqlquery.dbname="ctp2") # sqlquery的数据库参数预先设置

#' 数据库函数
#' @param f 连接执行函数
#' @param 执行SQL语句 的函数
dbfun <- function(f, ...) {
  dbcfg <- match.call(expand.dots=F)$... |> lapply(\(x) tryCatch(eval(x), error=\(e) deparse(x))) # 数据库连接参数配置(尝试求值，失败则解释符号名为字符串)
  defaultcfg <- list( # 从 global options 中提取默认连接参数
    drv = getOption("sqlquery.drv", MySQL()), 
    host = getOption("sqlquery.host", "localhost"), 
    user = getOption("sqlquery.user", "root"), 
    password = getOption("sqlquery.password", "123456"), 
    port = getOption("sqlquery.port", 3371), 
    dbname = getOption("sqlquery.dbname", "ctp2")) # 默认连接参数
  readcfg <- \(key) dbcfg[[key]] %||% defaultcfg[[key]] #  带有默认值的配置参数key的值读取 

  #' 执行SQL语句
  #' @param sql  SQL语句
  function (sql) {
    # 数据库连接
    tryCatch({
      keys <- "drv,host,user,password,port,dbname" |> strsplit(",") |> unlist() # 配置参数keys向量
      con <- structure(keys, names=keys) |> lapply(readcfg)  |> do.call(dbConnect, args=_ ) # 读取配置并获得数据库连接
      on.exit(dbDisconnect(con), add=TRUE) # 注册函数运行结束时关闭调该数据库连接con
      f(con) # 执行sql
    }, error=\(err) {
      print(sprintf("sql:%s", sql)) # 打印错误sql
      stop(err) # 重新抛出错误
    }) # 数据库连接
  } # function (sql)
} # dbfun

# 执行SQL语句查询数据结果（操作结果集模式)
# sql 语句是向量化的，当 sql长度大于1，返回一个 tibble 列表，否则 返回一个 tibble 对象
# simplify 是否对查询结果做简化处理后再返回，
#   T:  简化处理，即 对于只有单个元素的查询结果（单元素列表），直接返回该元素；
#   F：不做简化处理，直接返回 查询结果（列表），不论该结果是否为单元素列表
# n 查询结果的返回最大数量
sqlquery <- function(sql, simplify=T, n=-1, ...) {
  # 连接使用函数
  dbfun(function (con) { # 使用数据库连接进行查询结果数据集
    sqls <- c(list(), sql) #  拼装成sql语句集合
    dataset <- lapply(sqls, \(s) { # SQL语句执行
      rs <- dbSendQuery(con, s) # 数据查询
      entries <- fetch(rs, n) # 获取所有结果行
      dbClearResult(rs) # 关闭结果集
      tibble(entries) # 结果转换成 tibble对象
    }) |> structure(names=sql) # 数据查询
    if( simplify & length(dataset) == 1 )  dataset[[1]]  else  dataset  # 返回结果数据集
  }, ...)(sql) # 连接使用函数
}

#' 执行SQL语句查询数据结果（dbGetQuery模式)
#' @param sql 语句是向量化的，当 sql长度大于1，返回一个 tibble 列表，否则 返回一个 tibble 对象
#' @param simplify 是否对查询结果做简化处理后再返回，
#'   T:  简化处理，即 对于只有单个元素的查询结果（单元素列表），直接返回该元素；
#'   F：不做简化处理，直接返回 查询结果（列表），不论该结果是否为单元素列表
#' @param n 查询结果的返回最大数量
#' @param pretty 结果美化函数，可以做一些数据R层面的后处理, 类型转换或是结果与当前执行环境的融合合并,do.call(x)等:
#'   sqlquery("show tables") |> head() %>% sprintf(fmt="select '%s' tbl, count(*) n from %s t limit 2", ., .) |> sqlquery(prettify=bind_rows)
#' @return 返回结果数据集
sqlquery <- function(sql, simplify = T, n = -1, prettify=\(x) if(1 == length(x)) x[[1]] else x, ...) {
  # 连接使用函数
  dbfun(\ (con, ...) { # 使用数据库连接进行查询结果数据集
    dataset <- c(list(), sql) |> lapply(compose(tibble, partial(dbGetQuery, con=con, n=n))) |> structure(names=sql) # 执行数据查询
    prettify(if(simplify & length(dataset) == 1) dataset[[1]] else dataset)  # 返回结果数据集
  }, ...)(sql) # 连接使用函数
}

# 执行SQL语句（dbExecute模式)
# sql 语句是向量化的，当 sql长度大于1，返回一个 tibble 列表，否则 返回一个 tibble 对象
# simplify 是否对查询结果做简化处理后再返回，
#   T:  简化处理，即 对于只有单个元素的查询结果（单元素列表），直接返回该元素；
#   F：不做简化处理，直接返回 查询结果（列表），不论该结果是否为单元素列表
# 返回结果是 affected_rows, last_insert_id 两列的数据框，对于
# insert into t_user(name) values('name_1'),('name_2'),...,('name_n') 一条语句插入多条数据
# 的情况affected_rows返回实际插入的数量，last_insert_id返回插入的第一条数据的id
# 其余id请根据last_insert_id,affected_rows依次计算，比如name_1的id为x，那么name_2就是x+1,...，name_n为x+n-1
# 返回实际插入数据的id为: seq(from=last_insert_id,lengout.out=affected_rows)
sqlexecute <- function(sql, simplify=T, ...) {
    # 连接使用函数
    dbfun(\ (con) { # 使用数据库连接进行查询结果数据集
      tryCatch({ # try 运行结果
        dbBegin(con) # 开启事务
        dataset <- c(list(), sql) |> lapply(\(.sql){
          affected_rows <- dbExecute(con, .sql); # 影响数据行数
          last_insert_id <-  dbGetQuery(con, "SELECT LAST_INSERT_ID()") |> unlist() # 获取插入的Id
          list(affected_rows=affected_rows, last_insert_id=last_insert_id) # 返回结果
        }) |> do.call(rbind, args=_) |> tibble() # 执行数据查询
        dbCommit(con) # 提交事务
        if( simplify & length(dataset) == 1 )  dataset[[1]]  else  dataset  # 返回结果数据集
      }, error=\(err) { # 错误处理
        dbRollback(con) # 回滚错误
        stop(err) # 重新抛出错误
      }) # try 运行结果
    }, ...)(sql) # 连接使用函数
}

#' 创建数据表SQL
#' @param dfm 数据框数据
#' @param tbl  数据表名
#' @return 创建数据表SQL
ctsql <- function( dfm, tbl ) {
  tbl <- if(missing(tbl)) deparse( substitute( dfm ) )  else tbl #  提取数据表名
  dfm |> lapply(\(e, t=typeof(e), cls=class(e), # 基础类型与class包含高级类型list
      n=as.integer(Reduce(\(acc, a) max(acc, max(acc, nchar(a))), x=as.character(e), init=0) * 1.5), # 列数据宽度
      default_type=sprintf('varchar(%s)', n) # 默认类型
    ) switch(t, # 类型判断
        `logical`='bool', # 布尔类型
        `integer`=if(cls=='factor') default_type else 'integer', # 列表类型
        `double`=if(any(grepl(pattern="Date|POSIXct|POSIXt", x=cls))) "datetime" else 'double', # 列表类型
        `list`='json', # 列表类型
        default_type # 默认类型 
    )) |> (\(x) # 获取字段定义
      sprintf("create table %s (\n  %s \n)\n", tbl, paste(names(x), x, collapse=",\n  ")) # 数据表创建语句 
    ) () # SQL 创建表语句
}

#' 表数据插入SQL
#' @param dfm 数据框数据
#' @param tbl  数据表名
#' @return 表数据插入SQL
insql <- function( dfm, tbl ) {
  tbl <- if(missing(tbl)) deparse( substitute( dfm ) )  else tbl #  提取数据表名
  keys <- names( dfm ) |> paste(collapse=", ") # 列名列表
  values <- dfm |> lapply(\(e, t=typeof(e), cls=class(e)) # 记录值列表的各个字段值处理：
    switch(t, # 元素类型判断，决定是否用单引号把数值括起来，数值与逻辑值不用，list 转换成列表
      `logical`=e, # 逻辑类型，保持原值不变
      `integer`=if(cls=='factor') sprintf("'%s'", e) else e, # 整数类型，保持原值不变
      `double`=if(any(grepl(pattern="Date|POSIXct|POSIXt", x=cls))) sprintf("'%s'", e) else e, # 双精度，保持原值不变
      `list`=sprintf("'%s'", gsub("'", "''", toJSON(e))), # list类型，转换成JSON, 并对单引号进行转义
      sprintf("'%s'", gsub("'", "''", e)) # 默认类型，使用单引号'给括起来, 并对单引号进行转义
    )) |> do.call(\(...) mapply(\(...) paste(..., sep=', ', collapse=','), ...), args=_) |> # 行映射,此处\(...)有层级差异,内为字段外为数据行是两个不同变量
    sprintf(fmt='( %s )') |> paste(collapse=',\n  ') # 值列表
  sprintf( "insert into %s (%s) values \n  %s\n", tbl, keys, values ) # SQL 插入记录行数据（多行）语句
}

#' 表数据更新SQL
#' @param dfm 数据框数据
#' @param tbl 数据表名
#' @param pk 数据主键
upsql <- \(dfm, tbl, pk="id") { # 数据更新
    nms <- names(dfm) # 提取各个数据列名
    idx <- match(pk, nms) #  主键pk在名称nms中的索引位置
    stopifnot("dfm的名称nms中必须包含主键名pk" = !is.na(idx)) # pk名字的有效性检测
    flds <- sapply(nms, \(i) sprintf("%s='%s'", i, dfm[, i, drop=T] |> gsub("'", "''",x=_))) |> 
      apply(1, \(line) paste(line[-idx], collapse=",\n  ")) # 字段拼接
    sprintf("update %s set\n  %s \nwhere %s='%s'\n", tbl, flds, pk, dfm[, pk]) # 数据更新的SQL语句
}

#' 带有动态参数计算能力：sqlexecute2(sql, dbname=test), 即dbname=test相当于dbname="test"，合法标识符名可以不打引号而直接获得符号名!
#' 但是"eval.parent(substitute(... ...))"与partial的固定参数机制相冲突：
#' 这种自定义数据库的定义SQL查询方式是不可以的：sqlquery.test <- partial(sqlquery2, dbname="test") 
#' 需要写成确定参数形式：sqlquery.test <- \(sql) sqlquery2(sql, dbname="test")
#' 对于静态SQL这两种范式没有区别，但是对于动态生成的sql语句的dynamic_sql() 就差别很大了！
#' 即partial方式定义的sqlquery.test不能用于这种形式：dynamic_sql() |> sqlquery.test()， dynamic_sql() 会生成一场！
#' 
#' 执行SQL语句查询数据结果（dbGetQuery模式)
#' @param sql 语句是向量化的，当 sql长度大于1，返回一个 tibble 列表，否则 返回一个 tibble 对象
#' @param simplify 是否对查询结果做简化处理后再返回，
#'   T:  简化处理，即 对于只有单个元素的查询结果（单元素列表），直接返回该元素；
#'   F：不做简化处理，直接返回 查询结果（列表），不论该结果是否为单元素列表
#' @param n 查询结果的返回最大数量
#' @return 返回结果数据集
sqlquery2 <- function(sql, simplify=T, n=-1, ...) {
  # 连接使用函数:使用"eval.parent(substitute(... ...)) 去封装dbfun调用，可以避免R把实际"..."给改写"..1, ..2"的形式：
  # 否则，sqlquery(sql, dbname=ctp) 会被翻译成 sqlexecute(sql, ..1=ctp) 而改掉了参数名
  eval.parent(substitute(dbfun(\ (con) { # 使用数据库连接进行查询结果数据集
    dataset <- c(list(), sql) |> lapply(compose(tibble, partial(dbGetQuery, con=con, n=n))) |> structure(names=sql) # 执行数据查询
    if( simplify & length(dataset) == 1 )  dataset[[1]]  else  dataset  # 返回结果数据集
  }, ...)(sql))) # 连接使用函数
}

#' 带有动态参数计算能力：sqlexecute2(sql, dbname=test), 即dbname=test相当于dbname="test"，合法标识符名可以不打引号而直接获得符号名!
#' 但是"eval.parent(substitute(... ...))"与partial的固定参数机制相冲突：
#' 这这种自定义数据库的定义SQL执行方式是不可以的：sqlexecute.test <- partial(sqlexecute2, dbname=test) # 
#' 需要写成确定参数形式：sqlexecute.test <- \(sql) sqlexecute2(sql, dbname=test)
#' 对于静态SQL这两种范式没有区别，但是对于动态生成的sql语句的dynamic_sql() 就差别很大了！
#' 即partial方式定义的sqlquery.test不能用于这种形式：dynamic_sql() |> sqlexecute.test()， dynamic_sql() 会生成一场！
#' 
#' 执行SQL语句（dbExecute模式)
#' @param sql 语句是向量化的，当 sql长度大于1，返回一个 tibble 列表，否则 返回一个 tibble 对象
#' @param simplify 是否对查询结果做简化处理后再返回，
#'   T:  简化处理，即 对于只有单个元素的查询结果（单元素列表），直接返回该元素；
#'   F：不做简化处理，直接返回 查询结果（列表），不论该结果是否为单元素列表
#' @return 返回结果是 affected_rows, last_insert_id 两列的数据框，对于
#'    insert into t_user(name) values('name_1'),('name_2'),...,('name_n') 一条语句插入多条数据
#'    的情况affected_rows返回实际插入的数量，last_insert_id返回插入的第一条数据的id
#'    其余id请根据last_insert_id,affected_rows依次计算，比如name_1的id为x，那么name_2就是x+1,...，name_n为x+n-1
#'    返回实际插入数据的id为: seq(from=last_insert_id,lengout.out=affected_rows)
sqlexecute2 <- function(sql, simplify=T, ...) {
    # 连接使用函数:使用"eval.parent(substitute(... ...)) 去封装dbfun调用，可以避免R把实际"..."给改写"..1, ..2"的形式：
    # 否则，sqlexecute(sql, dbname=ctp) 会被翻译成 sqlexecute(sql, ..1=ctp) 而改掉了参数名
    eval.parent(substitute(dbfun(\ (con) { # 使用数据库连接进行查询结果数据集
      tryCatch({ # try 运行结果
        dbBegin(con) # 开启事务
        dataset <- c(list(), sql) |> lapply(\(.sql){
          affected_rows <- dbExecute(con, .sql); # 影响数据行数
          last_insert_id <-  dbGetQuery(con, "SELECT LAST_INSERT_ID()") |> unlist() # 获取插入的Id
          list(affected_rows=affected_rows, last_insert_id=last_insert_id) # 返回结果
        }) |> do.call(rbind, args=_) |> tibble() # 执行数据查询
        dbCommit(con) # 提交事务
        if( simplify & length(dataset) == 1 )  dataset[[1]]  else  dataset  # 返回结果数据集
      }, error=\(err) { # 错误处理
        dbRollback(con) # 回滚错误
        stop(err) # 重新抛出错误
      }) # try 运行结果
    }, ...)(sql))) # 连接使用函数
}

#' 解析SQL脚本文件为命名SQL语句列表
#'
#' 该函数读取SQL脚本文件，将其解析为命名SQL语句的列表。SQL脚本使用特殊注释格式来标识不同的SQL语句块。
#'
#' @param input 字符向量，可以是文件路径或包含SQL脚本内容的字符向量
#' @return 一个命名列表，其中名称是SQL语句的标题，值是相应的SQL语句内容
#'
#' @details
#' SQL脚本格式说明：
#' - 使用 `-- # 标题名` 格式来标识SQL语句块的开始
#' - `-- #参数名` 或 `-- ##参数名` 格式被视为参数注释，不会被识别为标题
#' - 支持行尾注释（使用 `--` 或 `//`）
#' - 自动过滤空行和纯注释行
#'
#' @examples
#' \dontrun{
#' # 从文件读取
#' sql_list <- script_file("path/to/sql_scripts.sql")
#'
#' # 从字符向量读取
#' sql_content <- c(
#'   "-- # 用户查询",
#'   "SELECT * FROM users",
#'   "WHERE active = TRUE",
#'   "",
#'   "-- # 产品统计",
#'   "SELECT category, COUNT(*) as count",
#'   "FROM products",
#'   "GROUP BY category"
#' )
#' sql_list <- script_file(sql_content)
#'
#' # 使用解析后的SQL语句
#' users_sql <- sql_list[["用户查询"]]
#' products_sql <- sql_list[["产品统计"]]
#' }
#'
#' @export
sqlfile <- function(input) {
  lines <- if (length(input)==1 && file.exists(input)) readLines(input, warn = FALSE) else
    if (is.character(input)) input else stop("无效输入")
  
  result <- Reduce(\(acc, line) {
    if (grepl("^\\s*--\\s*#\\s+([^#\\s].*?)\\s*$", line)) {
      if (!is.null(acc$title)) acc$stmts[[acc$title]] <- paste(acc$buffer, collapse = "\n")
      list(stmts = acc$stmts, title = sub("^\\s*--\\s*#\\s+([^#\\s].*?)\\s*$", "\\1", line), buffer = character())
    } else if (!grepl("^\\s*--", line) && nchar(trimws(line)) > 0) {
      list(stmts = acc$stmts, title = acc$title, buffer = c(acc$buffer, sub("\\s*((--)|(//)).*$", "", line)))
    } else acc
  }, lines, init = list(stmts = list(), title = NULL, buffer = character()))
  
  if (!is.null(result$title)) result$stmts[[result$title]] <- paste(result$buffer, collapse = "\n")
  result$stmts
}

#' Fill SQL Template with Parameters
#'
#' Replaces parameter placeholders in SQL templates with actual values.
#' Supports different formatting based on parameter prefix:
#' - `##param` parameters are inserted without quotes (for table/column names)
#' - `#param` parameters are wrapped in quotes (for string values)
#'
#' @param template Character string containing the SQL template with parameter placeholders
#' @param params Named list of parameters where names are parameter placeholders and values are replacements
#'
#' @return Character string with parameters substituted
#'
#' @examples
#' \dontrun{
#' # SQL template with parameters
#' sql_template <- "SELECT * FROM ##table WHERE date >= #start_date AND status = #status"
#' 
#' # Parameters
#' params <- list(
#'   "##table" = "users",
#'   "#start_date" = "2024-01-01", 
#'   "#status" = "active"
#' )
#' 
#' # Fill template
#' filled_sql <- sqlfill(sql_template, params)
#' cat(filled_sql)
#' # Output: SELECT * FROM users WHERE date >= '2024-01-01' AND status = 'active'
#' }
#'
#' @export
sqlfill <- function(template, params) {
  if (length(params) == 0) {
    return(template)
  }
  
  Reduce(
    f = function(acc, kv) {
      pattern <- kv[1]
      replacement <- kv[2]
      
      # Determine formatting based on parameter prefix
      format_spec <- switch(
        sub("^\\s*(#+)[^#]+", "\\1", pattern),
        "##" = "%s",  # No quotes for table/column names
        "'%s'"        # Quotes for string values
      )
      
      gsub(pattern, sprintf(format_spec, replacement), acc, fixed = TRUE)
    },
    x = mapply(c, names(params), params, SIMPLIFY = FALSE),
    init = template
  )
}

#' 对 record.builder生成的构建器 进行扩展
#' （采用循环填充rep_len模式的构建以及与options的sqlquery.rb.xxx配置相关默认配置）
#' 
#' 使用sqlquery.rb.keys配置项目进行默认键名读取
#' 1) sqlqeury.rb.tbl # rb构建器的默认合约数据表
#' 2) sqlqeury.rb.interval # rb构建器的默认时间跨度时长（单位小时）
#' @param rb record.builder生成的构建器
#' @return the extended record.builder
rbx <- \(rb) \(...) list(...) |> (\(., keys=environment(rb)$keys) { # 提取rb的键名
  flags <- "magrittr,lubridate" |> strsplit(",") |> unlist() |> (\(.) setNames(.,.))() |> sapply(require, character.only=T)
  if(!all(flags)) paste0(names(flags[!flags]), collapse=",") |> sprintf(fmt="make sure packages '%s' are all installed!") |> stop()
  
  # 生成键值序列的记录并进行调整
  setNames(rep_len(., length(keys)), keys) |> (\(rec) { # 采用循环填充rep_len的方式构造记录结构
      ftm <- \(tm) strftime(tm, "%H:%M:%S") # 时间格式化
      Reduce(\(acc, k, v=acc[[k]]) { # 对记录值进行私人定制
        if(identical("##tbl", k)) { # 表名字段处理
          .v <- gsub("\\s*", "", v) |> (\(.) ifelse(is.null(.) || is.na(.) || grepl("^$", .) || length(.) < 1, # 判断tbl参数是合法有效
            getOption("sqlquery.rb.instrument", "rb2605"), .)) () # 默认合约表
          if(grepl("^[[:alnum:]]+$", .v)) { # 金融期货合约进行增广处理
            timestamp <- (\(f) if(is.function(f)) strftime(f(), "%Y%m%d") else as.character(f)) (getOption("sqlquery.rb.timestamp", Sys.time))
            acc[[k]] <- "t_%s_%s" |> sprintf(.v, timestamp) # 默认表
          } # if
        } else if(grepl("time$", k)) { # 时间字段调整，对开始时间与结束时间进行默认值处理
          # 把".0930"格式化09:30:00;"150",格式化成15:30:00格式的简洁时间输入函数！命令行输入的API，长度少一个字符都有意义能短则短！
          # “小时小于2位小数记录，因为小数可以保护首位0，小时大于2位整数记录”，其余形式保持原样
          as.tm <- \(x, flag = is.numeric(x), n = as.integer(abs(x))) if(!flag) x else # 数据合法
            ifelse(n<1, as.character(abs(x)) |> substring(3, 8), format(n, scientific=F)) |> # 若是小数去除正整数部分，若是整数取消科学数法获得完整数字
              (\(k, h = nchar(k), pad = strrep("0", abs(6-h))) ifelse(h<6, paste0(k, pad), k)) () |> 
                substr(1, 6) |> gsub("(..)(..)(..)", "\\1:\\2:\\3", x=_) # 时间格式化
          # 把数字(从高到低截取前6位不足尾部补充0）转成%H:%M:%S格式的时间以方便时间输入
          .v <- gsub("\\s*", "", ifelse(grepl("^[.[:digit:]]*$", v), as.tm(v), v)) |> 
            (\(.) ifelse(!is.null(.) && length(.)>0 && grepl("^\\d{2}:\\d{2}$", .), paste0(., ":00"), .)) ()
          acc[[k]] <- if(tryCatch(hms(.v, quiet = T)) |> is.na()) { # 时间非法值
             switch(k, "#startime" = ftm(Sys.time() - getOption("sqlquery.rb.interval", 3) * 3600), "#endtime" = ftm(Sys.time()), .v) # 默认时间处理
          } else .v # 采用格式文本  
        } # if 时间字段
        acc # 返回累计值
      }, x = names(rec), init = rec) # 键值默认处理
    }) () # rec 记录处理
  }) () # keys

#' 使用拓展构建器进行简洁查询（采用循环填充rep_len模式的构建以及与options的sqlquery.rb.xxx配置相关默认配置）
#' sqldframe("1min.kline", rbx.tse(rb2605)) 从数据库中查询出最近两小时的合约K线！
#' rbx.tse(ma601, 0930, 1547) |> sqldframe('1min.kline',params=_)
#' 
#' 拓展合约表格时间TSE (Table,Startime,Endtime) 构建器
#' 使用sqlquery.rb.keys配置项目进行默认键名读取
rbx.tse <- \(...) { # 扩展表格时间
  .rb.tse <- do.call(record.builder, args=list(getOption("sqlquery.rb.keys", "##tbl,#startime,#endtime"))) # 动态创建标准构建器
  call_env <- parent.frame() # 调用者环境，以便eval(e, call_env)可正确算出rbx.tse的实际参数（展开...），parent.frame是类似于商品交易的上一家是相对为非固定的
  match.call(expand.dots = FALSE)$... |> # 展开参数
    lapply(\(e) tryCatch(eval(e, call_env), error = \(err) deparse(e))) |>
    do.call(rbx(.rb.tse), args = _) # 将标准构建器封装成扩展构建器
}

# ----------------------------------------------------------------------------------------------------------------
# 动态参数计算，sqlquery vs sqlquery2 以及 sqlexecute  vs sqlexecute2
# ----------------------------------------------------------------------------------------------------------------

# sqlquery没有动态参数计算能力
> sqlquery("show tables", dbname=test)
[1] "sql:show tables"
Error in .local(drv, ...) : 
  Failed to connect to database: Error: Unknown database '..1'
> 

# sqlquery2拥有动态参数能力
> sqlquery2("show tables", dbname=test)
# A tibble: 1 × 1
  Tables_in_test
  <chr>         
1 t_iris        

# 可以使用partial 函数进行sqlquery.test
# sqlquery.test <- partial(sqlquery, dbname="test") # 自定义数据库查询
# sqlexecute.test <- partial(sqlexecute, dbname="test") # 自定义数据库执行

local({ # 数据库写入测试
  # sqlquery(查询), sqlexecute(执行), ctsql(创建), insql(插入), upsql(更新) 等关系数据库的基础工具函数载入！
  # 此类基础工具函数默认关系数据表拥有一个带有自增长结构的主键id！
  batch_load() # 基础工具的批量载入
  
  # test 数据库查询函数
  sqlquery.test <- partial(sqlquery, dbname="test") # 自定义数据库查询
  sqlexecute.test <- partial(sqlexecute, dbname="test") # 自定义数据库执行
  
  # 安装必要的使用工具包：janitor用于创建clean_name
  "janitor,RMySQL" |> strsplit(",") |> unlist() |> lapply(\(pkg) {
     if(!require(pkg, character.only=T)) { 
       install.packages(pkg); 
       library(pkg, character.only=T)
     } else T
  })
  sqlexecute.test("drop table if exists t_iris") # 查询数据
  
  # 把 iris数据导入数据库
  df <- cbind(id=1:dim(iris)[1], iris) # 增加主键数据
  names(df) <- make_clean_names(names(df)) # 美化字段名
  c(ctsql, insql) |> lapply(\(f) f(df, "t_iris") |> sqlexecute.test()) # 创建表并插入数据
  sqlquery.test("select * from t_iris") # 查询数据
})

###### 
sqlexecute.test <- partial(sqlexecute, dbname="test") # 自定义数据库执行
sqlexecute.test("drop table if exists t_iris") # 查询数据
c(ctsql, insql) |> lapply(\(f) f(df, "t_iris") |> sqlexecute.test()) # 创建表并插入数据

> c(ctsql, insql) |> lapply(\(f) f(df, "t_iris") |> sqlexecute.test()) # 创建表并插入数据
[[1]]
     affected_rows last_insert_id
[1,] 0             0             

[[2]]
     affected_rows last_insert_id
[1,] 150           0          

# 动态参数：错误执行
sqlexecute.test <- partial(sqlexecute2, dbname="test") # 自定义数据库执行
sqlexecute.test("drop table if exists t_iris") # 查询数据
c(ctsql, insql) |> lapply(\(f) f(df, "t_iris") |> sqlexecute.test()) # 创建表并插入数据

> c(ctsql, insql) |> lapply(\(f) f(df, "t_iris") |> sqlexecute.test()) # 创建表并插入数据
Error in f(df, "t_iris") : could not find function "f"


# ----------------------------------------------------------------------------------------------------------------
# 基本使用示例
# ----------------------------------------------------------------------------------------------------------------

# 查看默认数据库（ctp2）中的数据表
sqlquery("show tables")

# 查看默认数据库（ctp2）中的数据表, 扁平化的方式一个不带有名称的字符串向量
sqlquery("show tables") |> Reduce(x=_, c)

# 查看数据库名称与该数据库中的数据表
sqlquery(c("select database()", "show tables"))

# 查看数据库名称与该数据库中的数据表, 指定数据库
sqlquery(c("select database()","show tables"), dbname="ctp")

# 读取指定名称模式的数据表
sqlquery("show tables") |> compose(sqlquery, partial(sprintf, fmt="select * from %s"), partial(grep, pattern="ma", value=T), unlist)()

# 查看价格分布
sqlquery('select * from t_ma501_20241218') |> with(boxplot(LastPrice~substr(UpdateTime,1,2)))

# 查看指定数据库名称下面的数据表
(\( x, dbnames=x |> strsplit(",") |> unlist()) # x 逗号分割的数据库名称字符串, dbnames数据库名称向量
  dbnames |> lapply( \(dbname, sql) sqlquery(sql, dbname=dbname) |> getElement(1), sql="show tables") |> structure(names=dbnames) ) ("ctp,ctp2")

# 读取时间序列
sqlquery("select * from t_ma505_20241219") |> with(PyctpCreateTime |>as.POSIXct() |> xts(order.by=_, data.frame(LastPrice, Volume, OpenInterest)))

# 自定义主机与数据库
sqlquery.h10ctp <- partial(sqlquery, host="192.168.1.10", dbname="ctp") # 自定义SQL函数
# 可以用 unlist() 把只有一行数据数据的的结果变成一个单值向量，这个对于利用SQL函数比database()这样的结果是很方便的，但是对于多行多列的情况
# 结果就可能有点混乱（不同行相同里列的名称会添加一个数字序号），所以需要根据情况适当使用
sqlquery.h10ctp("select database()") |> unlist()

# ----------------------------------------------------------------------------------------------------------------
# sqlfile 使用示例
# ----------------------------------------------------------------------------------------------------------------

# sqlfile文件示例
# shell 生成 kline.sql 文件
cat >> kline.sql << EOF 
-- ---------------------------------------------------------------
-- 根据指定表名生成K线数据
-- # 1min
-- ##tbl 表名
-- #startime 开始时间
-- #endtime 结束时间
-- ---------------------------------------------------------------
WITH MinuteKLine AS (
    SELECT
        REGEXP_SUBSTR('##tbl', '(?<=t_).*?(?=_\\d{8}$)') Symbol,
        STR_TO_DATE(REGEXP_SUBSTR('##tbl', '\\d{8}$'), '%Y%m%d')  Date,  
        DATE_FORMAT(STR_TO_DATE(UpdateTime, '%H:%i:%s'), '%H:%i') as MinuteTime,
        FIRST_VALUE(LastPrice) OVER w as OpenPrice,
        MAX(LastPrice) OVER w as HighPrice,
        MIN(LastPrice) OVER w as LowPrice,
        FIRST_VALUE(LastPrice) OVER (w ORDER BY UpdateTime DESC) as ClosePrice,
        MAX(Volume) OVER w - MIN(Volume) OVER w as MinuteVolume,
        COUNT(*) OVER w as TradeCount
    FROM ##tbl
    WHERE Volume > 0 AND UpdateTime > #startime AND UpdateTime < #endtime
    WINDOW w AS (PARTITION BY DATE_FORMAT(STR_TO_DATE(UpdateTime, '%H:%i:%s'), '%H:%i'))
)
SELECT DISTINCT *
FROM MinuteKLine
ORDER BY MinuteTime

-- ---------------------------------------------------------------
-- 根据指定表名生成K线数据
-- # 1min_maxcnt
-- ##tbl 表名
-- #startime 开始时间
-- #endtime 结束时间
-- ---------------------------------------------------------------
WITH MinuteKLine AS (
    SELECT
        REGEXP_SUBSTR('##tbl', '(?<=t_).*?(?=_\\d{8}$)') Symbol,
        STR_TO_DATE(REGEXP_SUBSTR('##tbl', '\\d{8}$'), '%Y%m%d')  Date, 
        DATE_FORMAT(STR_TO_DATE(UpdateTime, '%H:%i:%s'), '%H:%i') as MinuteTime,
        FIRST_VALUE(LastPrice) OVER w as OpenPrice,
        MAX(LastPrice) OVER w as HighPrice,
        MIN(LastPrice) OVER w as LowPrice,
        FIRST_VALUE(LastPrice) OVER (w ORDER BY UpdateTime DESC) as ClosePrice,
        MAX(Volume) OVER w - MIN(Volume) OVER w as MinuteVolume,
        COUNT(*) OVER w as TradeCount
    FROM ##tbl
    WHERE Volume > 0 AND UpdateTime > #startime AND UpdateTime < #endtime
    WINDOW w AS (PARTITION BY DATE_FORMAT(STR_TO_DATE(UpdateTime, '%H:%i:%s'), '%H:%i'))
)
SELECT DISTINCT *
FROM MinuteKLine
ORDER BY MinuteTime
LIMIT ##maxcnt

EOF

# sql 语句模板的读取与处理
local({
   # sqlfile模板测试
  cat("-----------------------------------------\n")
  cat("# SQL语句模板的填充示例\n")
  cat("-----------------------------------------\n")
  lines <- c( # 文本行向量
      "-- # 用户查询",
      "SELECT user_id, username, email",
      "FROM users",
      "WHERE status = #status -- 只查询活跃用户",
      "",
      "-- # 订单统计",
      "SELECT COUNT(*) as order_count, SUM(amount) as total_amount",
      "FROM orders",
      "WHERE order_date BETWEEN #begtime AND #endtime",
      "LIMIT ##maxcnt")
   
  sqls <- sqlfile( lines) # 读取语句模板
  sqlfill(sqls[["用户查询"]], list("#status"="active")) |> cat("\n")
  cat("-----------------------------------------\n")
  sqlfill(sqls[["订单统计"]], list("#begtime"="9:00:00", "#endtime"="18:00:00", "##maxcnt"=100))  |> cat("\n")
  cat("-----------------------------------------\n")
  cat("# K线读取示例\n")
  cat("-----------------------------------------\n")
  # sqlfile文件读取测试
  params <- list("##tbl"="t_rb2601_20251117", "#startime"="13:00", "#endtime"="15:00", "##maxcnt"=5) # sql参数
  sql <- sqlfill(sqlfile("kline.sql")[["1min_maxcnt"]], params) ; cat(sql, "\n") # sql语句
  ds00ctp <- partial(sqlquery, dbname="ctp") # ds:datasource, 00:本机ip, ctp:数据名称
  kldata <- ds00ctp(sql) ; kldata # K线数据
})

# 返回结果示例
# # A tibble: 5 × 7
#   MinuteTime OpenPrice HighPrice LowPrice ClosePrice MinuteVolume TradeCount
#   <chr>          <dbl>     <dbl>    <dbl>      <dbl>        <dbl>      <dbl>
# 1 13:30           3079      3084     3079       3083         7123        120
# 2 13:31           3083      3089     3082       3089        24068        120
# 3 13:32           3089      3089     3087       3087         9654        120
# 4 13:33           3087      3089     3087       3088         3968        120
# 5 13:34           3088      3089     3087       3088         4990        120
# >

#  创建一个本地的sql文件
mkdir sql
cat >> sql/mykline.sql <<EOF
-- ---------------------------------------------------------------
-- 根据指定表名生成K线数据(带有tickdata源数据)
-- # tickdata.1min.kline
-- ##tbl 表名
-- #startime 开始时间
-- #endtime 结束时间
-- ---------------------------------------------------------------
WITH MinuteKLine AS (
    SELECT 
        Id,
        LastPrice,
        UpdateTime,
        Volume,
        DATE_FORMAT(STR_TO_DATE(UpdateTime, '%H:%i:%s'), '%H:%i') as MinuteTime,
        FIRST_VALUE(LastPrice) OVER w as OpenPrice,
        MAX(LastPrice) OVER w as HighPrice,
        MIN(LastPrice) OVER w as LowPrice,
        FIRST_VALUE(LastPrice) OVER (w ORDER BY UpdateTime DESC) as ClosePrice,
        MAX(Volume) OVER w - MIN(Volume) OVER w as MinuteVolume,
        COUNT(*) OVER w as TradeCount
    FROM ##tbl
    WHERE Volume > 0 AND UpdateTime > #startime AND UpdateTime < #endtime
    WINDOW w AS (PARTITION BY DATE_FORMAT(STR_TO_DATE(UpdateTime, '%H:%i:%s'), '%H:%i'))
)
SELECT 
    Id,
    REGEXP_SUBSTR('##tbl', '(?<=t_).*?(?=_\\d{8}$)') Symbol,
    STR_TO_DATE(REGEXP_SUBSTR('##tbl', '\\d{8}$'), '%Y%m%d')  Date,
    LastPrice,
    UpdateTime,
    Volume,
    MinuteTime,
    OpenPrice,
    HighPrice,
    LowPrice,
    ClosePrice,
    MinuteVolume,
    TradeCount
FROM MinuteKLine
ORDER BY UpdateTime, Id

EOF

# sqldframe读取sql模板文件
# 1min.kline为sql模板名称，如果本地目录(getwd())没有指定。
# 有效的模板pattern不能不能以sql关键字+" "为名称开头[不能满足以下模式:grepl(pattern, text, ignore.case = TRUE)]
# "^\\s*(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP|TRUNCATE|WITH|MERGE|BEGIN|COMMIT|
#   ROLLBACK|GRANT|REVOKE|EXPLAIN|DESC|SHOW|CALL|EXECUTE|DECLARE|SET)\\s" 这里的ROLLBACK换行只是美观的换行！
# sql模板名称 可以是字符串也可以是符号，sqldframe(xxx, ...) <==>sqldframe("xxx", ...), 但是符号需要时有效的R标识符
# 但对于“1min.kline”这种非法以数字开头的名称时一定需要用引号字符串的！
# sqldframe会在包malonylcoa安装目录下的sql文件夹里寻找
# 1min.kline,1min_maxcnt.kline为malonylcoa所自带的示例！
local({
    # 创建 参数列表构建器
    rb <- record.builder("##tbl,#startime,#endtime")
    # params设置为{"##tbl":["t_rb2601_20251118"],"#startime":["09:00"],"#endtime":["21:00"]} 
    params <- rb("t_rb2601_20251118", '09:00', "21:00")
    
    # 使用指定sql文件
    params |> sqldframe(params=_, "tickdata.1min.kline", files="./sql/mykline.sql", dbname="ctp", host="192.168.1.10")
    # 指定文件名模式
    params |> sqldframe(params=_, "tickdata.1min.kline", files="\\.sql$", dbname="ctp", host="192.168.1.10", recursive=T)
    # 使用包自带模板
    params |> sqldframe(params=_, "1min.kline", dbname="ctp", host="192.168.1.10")
   
   # 构建ds数据源:10号主机上的ctp数据库
   ds10ctp <- partial(sqldframe, dbname="ctp", host="192.168.1.10")
   ds10ctp("1min.kline", params)
   
   # 创建 参数列表构建器(带有maxcnt参数)
   rb2 <- record.builder("##tbl,#startime,#endtime,##maxcnt") 
   # 使用包默认
   rb2("t_rb2601_20251118", '09:00', "21:00", 5) |> sqldframe(params=_, "1min_maxcnt.kline", dbname="ctp", host="192.168.1.10")
   # 1min_maxcnt.kline 本地覆盖包文件
   rb2("t_rb2601_20251118", '09:00', "21:00", 5) |> sqldframe(params=_, "1min_maxcnt.kline", dbname="ctp", host="192.168.1.10", files="sql", recursive=T)
   
   # 创建 参数列表构建器(带有maxcnt参数)
   rb2 <- record.builder("##tbl,#startime,#endtime,##maxcnt") 
   rb2("t_rb2601_20251118", '09:00', "21:00", 5) |> sqldframe(params=_, "1min_maxcnt.kline", dbname="ctp")  # 本地检索
})

# 返回结果示例
# # A tibble: 5 × 7
#   MinuteTime OpenPrice HighPrice LowPrice ClosePrice MinuteVolume TradeCount
#   <chr>          <dbl>     <dbl>    <dbl>      <dbl>        <dbl>      <dbl>
# 1 09:01           3082      3084     3082       3083         2173         66
# 2 09:02           3082      3083     3081       3082         3272        120
# 3 09:03           3081      3083     3081       3082         3557        120
# 4 09:04           3082      3083     3081       3081         2382        120
# 5 09:05           3081      3082     3081       3082         2173        120

# #############################################
# 显示默认SQL模板， 默认是不进行文件夹的递归检索的
# 于是 当前目录下的sql文件夹的文件不予显示只罗列包默认
# function(files = "\\.sql$", recursive = FALSE, verbose = TRUE) 
# #############################################

> list_sql_templates()
Found 1 SQL files
Loaded 2 SQL templates:
  - Local: 0 (overrides package templates)
  - Package: 2
Package templates (2): 1min.kline, 1min_maxcnt.kline
$`1min.kline`
[1] "WITH MinuteKLine AS ( ...

$`1min_maxcnt.kline`
[1] "WITH MinuteKLine AS ( ...

attr(,"sources")
attr(,"sources")$`1min.kline`
[1] "package"

attr(,"sources")$`1min_maxcnt.kline`
[1] "package"

# #############################################
# 尝试将"sql"即files进行sql比对！（不做递归）
# 做直接文件名测试：file.exists(files) ，
# 如果失败，直接文件夹名测试dir.exists(files）, 
# （由于此例中含有sql文件夹，因此与下文的设置了递归参数
#     一样的效果，但这不是递归而是文件夹搜索）
# 如果直接读取失败，最后做正则表达式匹配！
# 注意：合法的sql模板文件需要以.sql作为后缀名！结果会经过
# purrr::keep(~ grepl("\\.sql$", .x, ignore.case = TRUE))过滤的
# #############################################
> list_sql_templates("sql")
Found 3 SQL files
Loaded 4 SQL templates:
  - Local: 3 (overrides package templates)
  - Package: 1
Local templates (3): 1min.kline2, 1min_maxcnt.kline, tickdata.1min.kline
Package templates (1): 1min.kline
$`1min.kline2`
[1] "WITH MinuteKLine AS (.. ...

$`1min_maxcnt.kline`
[1] "WITH MinuteKLine AS (.. 

$tickdata.1min.kline
[1] "WITH MinuteKLine AS ( ...

$`1min.kline`
[1] "WITH MinuteKLine AS (...

attr(,"sources")
attr(,"sources")$`1min.kline2`
[1] "local"

attr(,"sources")$`1min_maxcnt.kline`
[1] "local"

attr(,"sources")$tickdata.1min.kline
[1] "local"

attr(,"sources")$`1min.kline`
[1] "package"

# #############################################
# 递归查询 
# #############################################
# 本地文件sql/mykline.sql:{tickdata.1min.kline}, kline.sql:{1min.kline2,  *1min_maxcnt.kline}
# 包默认  sql/kline.sql:{kline.sql:{1min.kline, 1min_maxcnt.kline}}

> list_sql_templates("sql", recursive=T)
Found 3 SQL files
Loaded 4 SQL templates:
  - Local: 3 (overrides package templates)
  - Package: 1
Local templates (3): 1min.kline2, 1min_maxcnt.kline, tickdata.1min.kline
Package templates (1): 1min.kline
$`1min.kline2`
[1] "WITH MinuteKLine AS ( ...

$`1min_maxcnt.kline`
[1] "WITH MinuteKLine AS ( ...

$tickdata.1min.kline
[1] "WITH MinuteKLine AS ( ...

$`1min.kline`
[1] "WITH MinuteKLine AS ( ...

attr(,"sources")
attr(,"sources")$`1min.kline2`
[1] "local"

attr(,"sources")$`1min_maxcnt.kline`
[1] "local"

attr(,"sources")$tickdata.1min.kline
[1] "local"

attr(,"sources")$`1min.kline`
[1] "package"

# ----------------------------------------------------------------------------------------------------------------
# 多表计算示例
# ----------------------------------------------------------------------------------------------------------------

# 进入R.home()/library/malonylcoa/sql/的全局包路径（即.libPaths()中的malonylcoa/sql目录）
# 比如WINDOWS的D:/sliced/develop/r/R-4.5.2/library/malonylcoa/sql
# CTRL+R 在 运行框 里 输入上述路径，打开文件夹窗口，再然后右键菜单"Git Bash here"，启动bash shell！ 
# 写入SQL模板文件(tickdata, tickdata2)
#
# 注意 'EOF' 在这里被打上了单引号！(还有，复制下文的文本结尾处的EOF后边不能多空格，否则终结不了输入！）
# 将<< EOF改为<< 'EOF'（单引号包裹分界符），Shell 会原样保留内容（不解析任何转义字符）。因为，只有如此
# 正则表达式"REGEXP_SUBSTR('##tbl', '(?<=t_).*?(?=_\\d{8}$)' ) symbol "才能原样输出，不然其中的'\\'会被转义成'\'
cat >> tickdata.sql << 'EOF' 
-- ---------------------------------------------------------------
-- 根据指定表名提取交易原数据
-- # tickdata
-- ##tbl 表名
-- ---------------------------------------------------------------
SELECT
    Id id, -- 主键索引
    -- 计算毫秒级时间戳：秒级时间戳*1000 + 毫秒数
    UNIX_TIMESTAMP(STR_TO_DATE(CONCAT(TradingDay, " ", UpdateTime), '%Y%m%d %H:%i:%s')) * 1000 + UpdateMillisec AS x, -- 毫秒级时间戳
    LastPrice y, -- 价格
    COALESCE(Volume-LAG(VOLUME) OVER(), 0)  vol, -- 成交量
    STR_TO_DATE(REGEXP_SUBSTR('##tbl', '\\d{8}$'), '%Y%m%d')  date, -- 日期
    UpdateTime time, -- 更新日期
    REGEXP_SUBSTR('##tbl', '(?<=t_).*?(?=_\\d{8}$)') symbol -- 合约代码
FROM ##tbl

-- ---------------------------------------------------------------
-- 根据指定表名提取交易原数据
-- # tickdata2
-- ##tbl 表名
-- ##startime  开始时间
-- ##endtime 结束时间
-- ---------------------------------------------------------------
SELECT
    Id id, -- 主键索引
    -- 计算毫秒级时间戳：秒级时间戳*1000 + 毫秒数
    UNIX_TIMESTAMP(STR_TO_DATE(CONCAT(TradingDay, " ", UpdateTime), '%Y%m%d %H:%i:%s')) * 1000 + UpdateMillisec AS x, -- 毫秒级时间戳
    LastPrice y, -- 价格
    COALESCE(Volume-LAG(VOLUME) OVER(), 0)  vol, -- 成交量
    STR_TO_DATE(REGEXP_SUBSTR('##tbl', '\\d{8}$'), '%Y%m%d')  date, -- 日期
    UpdateTime time, -- 更新日期
    REGEXP_SUBSTR('##tbl', '(?<=t_).*?(?=_\\d{8}$)') symbol -- 合约代码
FROM ##tbl 
WHERE UpdateTime BETWEEN #startime AND #endtime

EOF

# 模板文件读写
local({
    # 基础库加载
    batch_load()

    # 全数据
    rb <- record.builder("##tbl") # 记录构建器，将表名添加到sql模板tickdata之中
    .data <- sqldframe("show tables") |> unlist() |> grep(pattern="rb2601_202511[12][0-9]", value=T) |> # 指定数据表模式
        lapply(\(tbl) tickdata |> sqldframe(rb(tbl))) # 执行SQL模板查询数据
    data <- .data |> do.call(bind_rows, args=_) # 数据框合并成一个long格式数据
    #  整体绘图
    ggplot(data, aes(id, y, group=date)) + geom_line(aes(color=date)) # 数据绘图
  
    # 提取指定时间范围(进行串联）
    rb2 <- record.builder("##tbl,#startime,#endtime")
    .data2 <- sqldframe("show tables") |> unlist() |> grep(pattern="rb2601_202511[2][78]", value=T) |> # 指定数据表模式
        lapply(\(tbl) tickdata2 |> sqldframe(rb2(tbl, "09:00", "23:00"))) # 执行SQL模板查询数据
    data2 <- .data2 |> do.call(bind_rows, args=_) # 数据框合并成一个long格式数据
    # 分组绘图
    data2 |> within({ # 加入拟合数据（手动计算）
         yhat <- lm(y~x) %>% { # 模型洞察: model系数dump
            coefs <- coef(.) # 提取模型系数
            .yhat <- predict(.) # 线性回归(拟合值）
            yhat <- (\(b, k) k*x+b) (coefs[1], coefs[2]) # 手动计算拟合值（局部）
            print(head(.yhat-yhat)) # 显示头前值
            sprintf("{intercept:%s, slope:%s, diff:%s}\n", coefs[1], coefs[2],  sum(.yhat-yhat)) |> cat()
            .yhat # 模型拟合值
        } # 拟合值yhat 
        t <- as.POSIXct(x/1000) # 时间类型值
        h <- strftime(t, "%d/%H") # 时间名称
    }) |> ggplot(aes(h, y))  + geom_boxplot(aes(y=y)) + # 价格箱线图
        geom_line(aes(y=yhat, group=1), stat="summary", fun="mean", color="red") + # 拟合值均值
        geom_line(aes(y=yhat, group=2), stat="summary", fun="max", color="blue") + # 拟合值最大
        geom_line(aes(y=yhat, group=3), stat="summary", fun="min", color="green") + # 拟合值最小
        geom_line(aes(y=y, group=11), stat="summary", fun="mean", color="red", linewidth=2) + # 实际值均值
        geom_line(aes(y=y, group=12), stat="summary", fun="max", color="blue", linewidth=2) + # 实际值最大
        geom_line(aes(y=y, group=13), stat="summary", fun="min", color="green", linewidth=2)  # 实际值最小

    # SQL 语句的组织&查询
    rm(list=ls()) # 删除当前环境所有变量，清空环境！
    library(lubridate)   # 用于hm()、hms()等时间处理
    library(dplyr) # 可以把filter(is.trading(time))中的time解释为数据框字段名而不是stats:time函数
    library(ggplot2) #  数据绘图
    library(magrittr) # 引入三通算符 "%T>%"以dump过程中生成的SQL
    library(malonylcoa) # 引入record.builder,list_sql_templates,sqlfill,sqlquery等数据库操作函数

    # 记录构建器
    rb2 <- record.builder("##tbl,#startime,#endtime") # SQL模板参数的记录构建器

    #' 判断一个时点向量points是否位于交易时段tradingbreaks之中
    #' @param points 交易时点：hms 结构的时间值
    #' @param tradingspans 交易时段分点（hms 结构）序列，或者说交易时段结构定义:[start1,end1;start2,end2;...;starti,endi;...;startn,endn]
    #'  由于每个时段都是由两个分点(starti,endi)构成，因此，分点扁平化以后，偶数区间索引的位置（0,2,4,...）时段之间的间隔，即非交易时段！
    is.trading <- \(points, tradingbreaks="09:00,10:15;10:30,11:30;13:30,15:00;21:00,23:00") {
        .tradingbreaks <- (\(bs=tradingbreaks) if(is.character(bs)) bs |> strsplit("[,;]+") |> unlist() |> hm() else bs) () # 交易时段分点处理
        points |> (\(x) (if(is.period(x)) x else hms(x))) () |> findInterval(.tradingbreaks) %% 2 !=0 # 判断是否交易时间（偶数区间索引乃非交易时段）
     } # is.trading 时点是位于否交易时段

    # 数据处理：TickData
    data3 <- sqldframe("show tables") |> unlist() |> grep(pattern="rb2601_202511[1][789]", value=T) |> # 指定数据表模式
        lapply(\(tbl) list_sql_templates(verbose=F) |> with(tickdata2) |> sqlfill(rb2(tbl, "09:00", "23:00"))) |> # tickdata2模板填充
        paste0(collapse="\nUNION\n") |> sprintf(fmt="%s ORDER BY date, time, id") %T>% cat("\n") |> # 模板组织，UNION会打乱顺序，故需重新排序
        sqlquery() |> filter(is.trading(time)) # 数据查询并交易时段过滤（需加载dplyr否则time会被视为函数报错：cannot coerce type 'closure' to vector of type 'character'）

    # 数据绘图：TickData
    data3 |> ggplot(aes(seq(x), y)) + geom_point(aes(color=y))  + geom_line() + # 价格波动图
        with(data3, scale_x_continuous(labels=\(i, j=pmin(pmax(i,1), length(x))) sprintf("%s %s(%s)", date[j], time[j], j))) + # 保证索引j合理化
        labs(x="Time", y="Price", caption="合约价格", title="RB2601合约")

    # 数据处理：分钟K线数据
    data4 <- sqldframe("show tables") |> unlist() |> grep(pattern="ma601_202511[2][5-8]", value=T) |> # 指定数据表模式
        lapply(\(tbl) list_sql_templates(verbose=F) |> with(`1min.kline`) |> sqlfill(rb2(tbl, "09:00", "15:00"))) |> # tickdata2模板填充
        paste0(collapse=")\nUNION\n(") |> sprintf(fmt="(%s)") %T>% cat("\n") |> # 模板组织，补充首尾的括号，以匹配UNION引入的括号
        sqlquery() |> filter(is.trading(paste0(MinuteTime, ":00"))) |> arrange(Date, MinuteTime) |> # 数据查询并交易时段过滤
        mutate(Key=paste(Date, MinuteTime), Id=seq(Key)) |> # 生成键名Key字段与索引Id字段
        tail(100) # 最新的数量
    
    # 绘制K线图
    with(data4, ggplot(data4, aes(Id, ClosePrice)) + geom_line() + # 绘制收盘价曲线
        with(lm(ClosePrice~Id), geom_abline(intercept=coefficients[1], slope=coefficients[2], linewidth=2, color="blue")) + # 绘制趋势线
        geom_boxplot(stat = "identity", # 手动指定 boxplot 参数
            aes(group=Key, # 每个坐标点单独分组
                ymin=LowPrice, ymax=HighPrice), middle=(OpenPrice+ClosePrice)/2, # 最低，最高价
                lower=pmin(OpenPrice, ClosePrice), upper=pmax(OpenPrice, ClosePrice), # 开盘,收盘
            fill=ifelse(OpenPrice>ClosePrice, "green", "red")) + # 使用box模拟K线
        scale_x_continuous(labels=\(i, j=pmin(pmax(i, min(Id)), max(Id))) Key[match(j, Id)])) + # 保证索引j合理化(使用Id索引Key值)
        labs(x="Time", y="Price", caption="合约价格", title="MA2601合约")

})

# quantmod OHLC绘图
local({
    # 基础库加载(导入sqlfill,rbx.tse,sqlquery等自定义符号到工作空间,把其所在的相应环境attach到isearchpaths的包检索路径之中)
    batch_load()

    # 计算交易时段验证的生成器, "trading breaks" : tbs
    is.trading.gen <- \(tbs="09:00,10:15;10:30,11:30;13:30,15:00;21:00,23:00") {
        breaks <- tbs |> strsplit("[,;]+") |> unlist() |> hm() # 生成时段分点
        \(x) findInterval(if(is.period(x)) x else hm(x), breaks) %% 2 != 0 # 返回交易时段过滤器
    }
    # 定义计算工具&资源对象
    is.trading <- is.trading.gen() # 生成交易函数
    rb <- record.builder("##tbl,#startime,#endtime") # 模板参数构建器
    tpls <- list_sql_templates() #  sql模板集合
    # 定义核心数据ohlcv的计算函数
    .ohlcv.ctp <- \(symbol, from, to, validate=is.trading) { #提取ctp的ohlc数据
        tbls <- sprintf("t_%s_%s", symbol, format(seq(as.Date(from), as.Date(to)-1, "day"), "%Y%m%d")) |> (\(.) .[. %in% sqlquery("show tables")]) ()
        if(length(tbls) < 1)  tibble() # 数据表为空
        else lapply(tbls, \(tbl) sqlfill(tpls$OHLCV1M, rb(tbl, '00:00', '23:59'))) |> sqlquery() |> dplyr::bind_rows() |> dplyr::filter(validate(hm(Time))) # 过滤验证
    }
    # 带有缓存的ohlcv.ctp, 是否更新缓存:flag
    ohlcv.ctp <- \(symbol, from, to, validate=is.trading, flag=F, home="./data/ctp/ohlcv") {
        if(!dir.exists(home)) mkdir(home) # 创建数据缓存
        fname <- do.call(sprintf, c(fmt=list("%s/%s_%s_%s.rds"), as.list(c(home, symbol, gsub("-", "", c(from, to)))))) # 缓存文件名称
        ohlcvs <- if(!flag && file.exists(fname)) readRDS(fname) #非覆盖标志且存在缓存
                        else .ohlcv.ctp(symbol, from, to) |> (\(x) {saveRDS(x, fname); x}) () #读取并缓存结果
    }

    # 数据生成与绘图
    system.time({ #生成过程计时（运算效率统计）
        ohlcvs <- ohlcv.ctp('rb2601', '2025-11-13', '2025-11-20', flag=T) # 测试数据
        ohlcvs |> with(xts(cbind(Open, High, Low, Close, Volume), as.POSIXct(paste(Date, Time)))) |> chartSeries(theme='white') # quantmod绘图
    }) # 生成过程计时（运算效率统计）
})

# ==============================================================================
# system.time的核心指标概念说明（技术+企业经营双视角类比）
# ==============================================================================
# user：R进程自身执行代码、处理核心逻辑的CPU耗时，
#       技术本质：纯“自己干”的运算时间，无外部依赖；
#       企业类比：团队内部梳理需求、处理数据、完成核心工作的实际干活时间，
#                代表企业自身的工作能力（管理效率、执行效率、核心业务处理能力）。
#
# system：操作系统内核为R进程提供服务的CPU耗时，
#         技术本质：系统级服务的运算时间（如IO、渲染、网络调用的内核处理）；
#         企业类比：外包/后勤团队帮对接资源、打印文件、处理标准化流程的实际干活时间，
#                  代表企业所在国内经济环境的基础治理效率（社会配套、行业基础设施、政企服务能力）。
#
# elapsed：代码从启动到结束的真实总耗时（包含所有干活+等待时间），
#          技术本质：总时间 = user + system + 外部资源等待时间（网络/IO/硬件等待）；
#          企业类比：从启动工作到最终交付成果的总时长 = 团队干活时间 + 外包干活时间 + 等待物流运输/外部资源的时间，
#                   其中等待时间代表外部客观条件的效率（航运、气象、供应链、政策响应等物流/资源流通效率）。
#
# 关键补充：elapsed - (user + system) = 纯外部等待时间，
#          技术层面：网络/数据库/硬件的等待耗时（核心性能瓶颈）；
#          企业层面：外部环境的不确定性耗时（如物流延迟、供应链卡顿、政策审批等待等）。
# ----------------------------------------------------------------------------------------------------------------------------------------
#
# 本地缓存读取（这是数据只在本地的执行情况，即没有物流采购，直接采用库存的OHLC的成品材料）
# ohlcvs <- ohlcv.ctp('rb2601', '2025-11-13', '2025-11-20', flag=F) # 测试数据
#   user  system elapsed 
#   0.45    0.87    1.33 
# 
# IO&DB企业的下单制造&执行（这是数据分布于外地/DB的执行情况，即包含物流采购，需要通过SQL给数据企业DB下单令其生产制造OHLC）
# ohlcvs <- ohlcv.ctp('rb2601', '2025-11-13', '2025-11-20', flag=T) # 测试数据
# >
#    user  system elapsed 
#    0.63    0.78   15.62 
#
# 示例：结合场景的双视角解读
system.time({
  # flag=T：调用CTP接口（依赖外部网络/数据库，对应企业依赖外部供应链/物流）
  ohlcvs <- ohlcv.ctp('rb2601', '2025-11-13', '2025-11-20', flag=T)  
  # 本地处理+绘图（企业内部核心工作+外包标准化工作）
  ohlcvs |> with(xts(cbind(Open, High, Low, Close, Volume), as.POSIXct(paste(Date, Time)))) |> chartSeries(theme='white')  
})
# 耗时解读（技术+企业视角）：
# user (~0.5s)：R核心数据处理 = 企业团队高效完成核心业务（自身能力强）；
# system (~0.8s)：系统IO/渲染服务 = 外包/后勤高效完成配套工作（外部基础环境良好）；
# elapsed (~15s)：总时长 = 1.3s干活时间 + 13.7s外部等待 = 企业自身+外包效率高，但物流/供应链延迟成为瓶颈。（因为OHLCV计算位于数据库端）
#
# 关键补充：elapsed - (user + system) 是纯等待时间，
#          类比：团队等待物流运输（网络/数据库IO）、外部部门响应的时间，也是核心性能瓶颈来源，即为R程序执行的提供的国际环境/外贸服务的运行效率！
# ==============================================================================

# 模板与多表混合检索
local({
    # 基础库加载(导入sqlfill,rbx.tse,sqlquery等自定义符号到工作空间,把其所在的相应环境attach到isearchpaths的包检索路径之中)
    batch_load()
    
    # 自定义sql 模板
    st <- "select PyctpCreateTime t, LastPrice x , coalesce(Volume-lag(Volume) over(), Volume) w from ##tbl" # 交易价格信息(x:price, w:weight)
    sqlfill(st, rbx.tse()) |> sqlquery() |> with(xts(cbind(x, w), as.POSIXct(t))) # 使用rbx.tse模板进行默认的当日合约填充并转成时间序列

    # 获取系统合约数据表
    tbls <- sqlquery("show tables") |> grep(pat="rb", value=T) # 提取螺纹钢tickdata数据表 
    symbols <- tbls %>%regmatches(x=., regexpr(text=., pattern="(?<=_)([^_]+)(?=_)", perl=T)) |> unique() # 从数据表名中提取合约符号

    # 批量合约查询并汇总
    tpls <- list_sql_templates() |> with(OHLCV1M) # 提取计算分钟K线的OHLCV的SQL模板
    rb <- record.builder("##tbl,#startime,#endtime") # SQL模板的参数构建器
    .tbls <- tbls |> sort() |> head(5) # 选择取前5个（数据很多，示例演示！）
    mapply(sqlfill, tpls, lapply(.tbls, \(tbl) rb(tbl, '09:00', '23:00'))) |> sqlquery() |> do.call(rbind, args=_) # 检索并汇总
})

# 数据示例
# >     mapply(sqlfill, tpls, lapply(.tbls, \(tbl) rb(tbl, '09:00', '23:00'))) |> sqlquery() |> do.call(rbind, args=_)
# # A tibble: 9 × 8
#   Symbol Date       Time   Open  High   Low Close Volume
# * <chr>  <chr>      <chr> <dbl> <dbl> <dbl> <dbl>  <dbl>
# 1 rb2505 2025-04-28 14:12  3060  3060  3059  3060    186
# 2 rb2505 2025-04-28 14:13  3060  3060  3059  3059    123
# 3 rb2505 2025-04-28 14:14  3059  3060  3058  3058     64
# 4 rb2505 2025-04-28 14:15  3058  3059  3057  3057    106
# 5 rb2505 2025-04-28 14:18  3057  3058  3057  3058    140
# 6 rb2506 2025-04-28 14:18  3068  3068  3068  3068      0
# 7 rb2507 2025-04-28 14:18  3103  3104  3103  3104     27
# 8 rb2508 2025-04-28 14:18  3106  3106  3106  3106      0
# 9 rb2509 2025-04-28 14:18  3113  3113  3113  3113      0


# ----------------------------------------------------------------------------------------------------------------
# 数据库读取示例
# ----------------------------------------------------------------------------------------------------------------

# 数据库的增删改查 (以test数据库为例)
# 首先在mysql数据库中创建数据库test: create database test default character set utf8mb4;
local({ # 数据库写入测试

  # sqlquery(查询), sqlexecute(执行), ctsql(创建), insql(插入), upsql(更新) 等关系数据库的基础工具函数载入！
  # 此类基础工具函数默认关系数据表拥有一个带有自增长结构的主键id！
  batch_load() # 基础工具的批量载入
  
  # test 数据库查询函数
  sqlquery.test <- partial(sqlquery, dbname="test") # 自定义数据库查询
  sqlexecute.test <- partial(sqlexecute, dbname="test") # 自定义数据库执行
  
  # 安装必要的使用工具包：janitor用于创建clean_name
  "janitor,RMySQL" |> strsplit(",") |> unlist() |> lapply(\(pkg) {
     if(!require(pkg, character.only=T)) { 
       install.packages(pkg); 
       library(pkg, character.only=T)
     } else T
  })

  # 把 iris数据导入数据库
  df <- cbind(id=1:dim(iris)[1], iris) # 增加主键数据
  names(df) <- make_clean_names(names(df)) # 美化字段名
  c(ctsql, insql) |> lapply(\(f) f(df, "t_iris")) |> sqlexecute.test() # 创建表并插入数据
  sqlquery.test("select * from t_iris") # 查询数据

  # 准备表数据
  dfm <- cbind(id=1:dim(mtcars)[1], mtcars) # 把mtcars转成数据表结构,添加一个ID结构。

  # 查询库表（建表前）
  sqlquery.test("show tables") |> unlist() |> grep(pattern="t_mtcars", value=T)
  # 创建数据表
  ctsql(dfm, "t_mtcars") |> sqlexecute.test() |> print()
  # 查询库表（建表后）
  sqlquery.test("show tables") |> unlist() |> grep(pattern="t_mtcars", value=T)
 
  # 插入表数据
  insql(dfm, "t_mtcars") |> sqlexecute.test() |> print()
  # 查询表数据（修改前）
  sqlquery.test("select * from t_mtcars")

  # 更新表数据
  dfm$cyl <- dfm$cyl + 2 # 增加一对儿气缸
  upsql(dfm, "t_mtcars") |> sqlexecute.test() |> print()
  # 查询表数据（修改后）
  sqlquery.test("select * from t_mtcars")

  # 删除表数据（删除第一条）
  sqlexecute.test("delete from t_mtcars where id=1")
  # 查询表数据（删除后）
  sqlquery.test("select * from t_mtcars")

  # 删除整个数据数据
  sqlquery.test("truncate t_mtcars")
  # 查询表数据（删除后）
  sqlquery.test("select * from t_mtcars")

  # 查询库表（删表前）
  sqlquery.test("show tables") |> unlist() |> grep(pattern="t_mtcars", value=T)
  # 删除整个表
  sqlquery.test("drop table t_mtcars")
  # 查询库表（删表后）
  sqlquery.test("show tables") |> unlist() |> grep(pattern="t_mtcars", value=T)

})

# 本地测试
local({ # 数据库写入测试

  # sqlquery(查询), sqlexecute(执行), ctsql(创建), insql(插入), upsql(更新) 等关系数据库的基础工具函数载入！
  # 此类基础工具函数默认关系数据表拥有一个带有自增长结构的主键id！
  batch_load() # 基础工具的批量载入
  
  # test 数据库查询函数
  sqlquery.test <- partial(sqlquery, dbname="test")
  # test 数据库执行函数
  sqlexecute.test <- partial(sqlexecute, dbname="test")
  
  # 删除数据表
  "t_mtcars" |> strsplit("[,;]+") |> unlist() |> sprintf(fmt="drop table if exists  %s") |> sqlexecute.test()
  # 创建表并插入数据
  c(ctsql, insql) |> lapply(\(f) f(mtcars, "t_mtcars") |> (\(s) {cat(s, "\n"); s})()) |> sqlexecute.test() |> print()
  # 查询结果数据 
  'select * from t_mtcars' |> sqlquery.test () |> print()

})

# 本地测试
local({ # 数据库写入测试

  # sqlquery(查询), sqlexecute(执行), ctsql(创建), insql(插入), upsql(更新) 等关系数据库的基础工具函数载入！
  # 此类基础工具函数默认关系数据表拥有一个带有自增长结构的主键id！
  batch_load() # 基础工具的批量载入

  # test 数据库查询函数
  sqlquery.test <- partial(sqlquery, dbname="test")
  # test 数据库执行函数
  sqlexecute.test <- partial(sqlexecute, dbname="test")
  
  # 删除数据表
  "t_user" |> strsplit("[,;]+") |> unlist() |> sprintf(fmt="drop table if exists  %s") |> sqlexecute.test()
  
  # 查看数据表
  "show tables" |> sqlquery.test()
  
  # 创建用户数据
  "create table t_user ( 
     id int primary key auto_increment comment '主键', 
     account varchar(64) comment '账户', 
     name varchar(64) comment '姓名', 
     password varchar(16) comment '密码', 
     sex varchar(10) comment '性别', 
     phone varchar(32) comment '电话', 
     weixin varchar(64) comment '微信', 
     description varchar(126) comment '说明'
   )" |> sqlexecute.test() # 创建数据表
  
  # 插入用户数据
  "zhangsan,lisi,wangwu,zhaoliu" |> strsplit("[,;]+") |> unlist() |> sprintf(fmt="insert into t_user(name) values('%s')") |> sqlexecute.test() |> print()
   sqlexecute.test( c( # SQL 插入语句
     "insert into t_user(name,password) values('chenqi','123456'),('zhouba','123456'),('yangjiu','123456'),('lushi','123456')",
     "insert into t_user(name,password) values('tom','123456'),('jerry','123456'),('katty','123456'),('lucy','123456')"
   ) ) |> print()
 # 查看数据
 sqlquery.test("select * from t_user")

})

# 本地测试:PostgreSQL的使用
local({ # 数据库写入测试
  
    # 安装数据库驱动&以及相关的工具库
    "RPostgres,purrr,dplyr,janitor,tibble" |> strsplit(",") |> unlist() |> lapply(\(pkg) {
        if(!require(pkg, character.only=T)) {
            install.packages(pkg)
            library(pkg, character.only=T)
        } else T # if
    })  # \(pkg)

    # 配置PostgreSQL数据库环境参数
    options("sqlquery.drv"=Postgres(), "sqlquery.dbname"="latinus",
        "sqlquery.host"="127.0.0.1", "sqlquery.port"=5432, 
        "sqlquery.user"="postgres", "sqlquery.password"="123456")

    # 连接数据库
    sqlquery("select version()") # 当前版本

    # 显示指定schema
    sqlquery("select * from economics.t_company")
  
    #' PostgreSQL API 
    #' 自定义查询函数 （手动设定shema）
    #' @param sql 查询语句
    #' @param search_path 检索路径
    #' @param simplify 是否简化模式
    #' @param verbose 息详情模式
    sqlquery.pg <- \(sql, search_path = "public,economics", simplify = T, verbose = F, ...) dbfun( \(con) { # 连接配置
        .log <- \(x) { if(verbose) cat(" -- ", x, "\n"); x } # 日志输出
        search_path |> strsplit("[,[:blank:]]+") |> unlist() |> sprintf(fmt="'%s'") |> paste0(collapse=", ") |> 
            sprintf(fmt="SET search_path to %s") |> .log() |> dbExecute(con, statement=_) # search_path 的设置
        (\(.sqls = c(sql)) .sqls |> .log() |> lapply(compose(tibble, dbGetQuery), conn=con) |> (\(res) # res 结果集简化
            if(simplify && 1 == length(res)) res[[1]] else structure(res, names=.sqls)) ()
        ) () # \(.sqls)
    }, ...) (sql) # dbfun \(con)
  
    #' PostgreSQL API  
    #' 自定义执行函数 （手动设定shema）
    #' @param sql 查询语句向量
    #' @param search_path 检索路径
    #' @param simplify 是否简化模式
    #' @param verbose 信息详情模式
    #' @param flag 事务开启标记, 需要注意PostgreSQL对于DML语句会自动进行提交，如果sql向量中同时包含有create,insert时
    #' 后面的语句就会跳出事务，语句执行了但是没有事务内结果且并不会报错。即，你不能在一个事务中先创建后插入，必须在非事务
    #' 环境中执行创建表与插入表的混合操作！
    sqlexecute.pg <- \(sql, search_path="public,economics", simplify=TRUE, verbose=F, flag=F, ...) {
        dbfun(\(con) {
            .log <- \(x) {if(verbose) cat(" -- ", x, "\n"); x}
            search_path |> strsplit("[,[:blank:]]+") |> unlist() |> sprintf(fmt="'%s'") |> paste0(collapse=",") |> 
            sprintf(fmt="SET search_path to %s") |> .log() |> dbExecute(con,statement=_)
            tryCatch({
                if(flag) dbBegin(con) # 开启事务
                rs <- lapply(c(sql), function(s) {
                    .sql <- .log(s) |> gsub(pattern="^\\s*|\\s*$", replacement="", x=_)
                    is.ddl <- grepl("^CREATE\\s+TABLE|^ALTER|^DROP", .sql, ignore.case=T)
                    is.insert <- grepl("^INSERT", .sql, ignore.case=T)
                    affected_rows <- ifelse(is.ddl, # 
                          dbSendStatement(con, .sql) |> (\(res) {n=dbGetRowsAffected(res); dbClearResult(res); n}) (),  # ddl 
                          dbExecute(con,.sql)) # not ddl(dml)
                    last_insert_id <- if(is.insert) tryCatch({dbGetQuery(con, "SELECT LASTVAL()") |> unlist()}, error=\(e) NA) else NA
                    list(affected_rows=affected_rows, last_insert_id=last_insert_id)
                }) |> do.call(rbind, args=_) 
                if(flag) dbCommit(con)  # 开启事务
                if(simplify && nrow(rs)==1) as.list(rs[1, ]) else rs
            }, error=\(err) {if(flag)dbRollback(con); stop(err)})
        }, ...) (sql)
    }
    
    #' PostgreSQL API  
    #' PostgreSQL 自增长主键（serial）并不会你手动设置主键之后进行同步，需要你手动给与同步设定，这与MySQL有很大不同，提请注意一下！
    #' 数据表创造语句: postgresql 版本
    ctsql.pg <- function( dfm, tbl ) {
        .tbl <- if(missing(tbl)) deparse( substitute( dfm ) )  else deparse( substitute( tbl ) ) |> gsub(pattern = "^['\"]|['\"]$", replacement = "")  #  提取数据表名
        dfm |> lapply(\(e, t=typeof(e), cls=class(e), # 基础类型与class包含高级类型list
            n=as.integer(Reduce(\(acc, a) max(acc, max(acc, nchar(a))), x=as.character(e), init=0) * 1.5), # 列数据宽度
            default_type=sprintf('varchar(%s)', n) # 默认类型
            ) switch(t, # 类型判断
                `logical`='boolean', # PostgreSQL布尔类型
                `integer`=if(cls=='factor') default_type else 'integer', # 整数类型
                `double`=if(any(grepl(pattern="Date", x=cls))) "date" else if(any(grepl(pattern="POSIXct|POSIXt", x=cls))) "timestamp with time zone" else 'double precision', # PostgreSQL浮点类型
                `character`=default_type, # 字符类型
                `list`='jsonb', # PostgreSQL JSONB类型
                `raw`='bytea', # 二进制类型
                default_type # 默认类型 
            )) |> (\(x) { # 获取字段定义
                if('id' %in% names(x)) x['id'] <- if(grepl('integer', x['id'])) 'serial primary key' else x['id']; # 主键处理
                sprintf("create table %s (\n  %s \n);\n", .tbl, paste(names(x), x, collapse=",\n  ")) # 数据表创建语句 
            }) () # SQL 创建表语句
    }

    # 数据查询
    sqlquery.pg("select current_schema") # 当前schema是public
    sqlquery.pg("select current_schema", "economics") # 当前schema是economics
    sqlquery.pg("select * from economics.t_company") # 在 public,economics 中检索数据表
 
    # 查询数据表
    "economics" |> sprintf(fmt=" SELECT table_name FROM information_schema.tables 
        WHERE table_schema='%s' AND table_type='BASE TABLE'") |> 
        sqlquery.pg() |> unlist() |> sprintf(fmt="select * from %s") |> sqlquery.pg(verbose=T)
    
    # 数据表删除
    sqlexecute.pg("drop table if exists t_iris", search_path="economics") # 查询数据

    # 把 iris数据导入数据库
    df <- cbind(id=1:dim(iris)[1], iris) # 增加主键数据
    names(df) <- make_clean_names(names(df)) # 美化字段名
    c(ctsql.pg, insql) |> lapply(\(f) f(df, "t_iris")) |> sqlexecute.pg(search_path="economics") # 创建表并插入数据
    sqlquery.pg("select * from t_iris", search_path="economics", verbose=T) # 查询数据

})

# 指定时段，动态过滤数据
local({
  library(rlang) # eval_tidy 的所在的库
  condition <- \( # 条件过滤函数
    text="09:00,10:15;10:30,11:30;13:00,15:00;21:00,23:00", # 时间区间
    points=text |> strsplit("[,;]+") |> unlist(), # 时点序列
    periods=points  |> ( \(x, n=length(x)/2) x |> split( rep( seq(n), rep(2,n) ) ) )(), # 把时点序列，组装成时段序列
    betweens=periods |>lapply(\(e) sprintf("between(UpdateTime, '%s:00', '%s:60')",e[1],e[2])) # 区间范围
  ) betweens |> paste0(collapse=" | ") |> str2lang()    # 组装成语句并解析成表达式对象
  # 数据读取
  # sqlquery('select * from t_ma505_20241209') |> dplyr::filter(eval_tidy(condition())) # 提取指定时段内的数据
  sqlquery('select * from t_ma505_20241209') |> dplyr::filter(eval_tidy(condition("09:00,09:03;09:05,09:07"))) # 提取指定时段内的数据
})

# 指定时段，动态过滤数据2
local({
  library(rlang) # eval_tidy 的所在的库
  condition <- \( # 条件过滤函数
    text="09:00,10:15;10:30,11:30;13:00,15:00;21:00,23:00", # 时间区间
    points=text |> strsplit("[,;]+") |> unlist(), # 时点序列
    periods=points  |> ( \(x, n=length(x)/2) x |> split( rep( seq(n), rep(2,n) ) ) )(), # 把时点序列，组装成时段序列
    betweens=periods |> lapply(\(p) expr( between(UpdateTime, !!p[1], !!p[2]) )) |> Reduce(\(acc,a) expr(!!acc | !!a), x=_) # 拼装成区间表达式
  )  betweens  # 组装成语句并解析成表达式对象
  # 数据读取
  # sqlquery('select * from t_ma505_20241209') |> dplyr::filter(eval_tidy(condition())) # 提取指定时段内的数据
  sqlquery('select * from t_ma505_20241209') |> dplyr::filter(eval_tidy(condition("09:00,09:03;09:05,09:07"))) # 提取指定时段内的数据
})

# 提取时间间隔超过误差精度的时段
local({
  # 读取时间序列
  sql <- "select * from t_ma505_20241219" # sql 语句
  x <- sqlquery(sql) |> with(PyctpCreateTime |> as.POSIXct() |> xts(order.by=_, data.frame(LastPrice, Volume, OpenInterest))) # tickdata 的时间序列
  gaps <- index(x) |> diff(units="mins") |> (\(ds) { # 计算时间间隔单位分钟
    # print(ds|>as.difftime(units = "secs") |> head()) # 转换成秒
    eps <- 1 # 时间间隔的区分精度单位分钟
    seq_along(ds)[ds > eps] |> (\(i, pre=x[i], cur=x[i+1]) list(pre=pre, cur=cur)) () # 超过限定间隔的时段
  }) () |> with(list(pre=pre, cur=cur) |> lapply(index) |> data.frame() ) # 空白时间区段
  print(gaps)
  rng <- range(index(x)) # 时间范围
}) |> print()

# 查询期货合约并合并，使之成为一个tibble数据对象 ，然后 写入一个data.ma505.csv的数据文件
local({ # data.table 的数据读取测试，以 local的方式限定 datafile，data 变量 的外部暴露
  library(data.table) # 加载库文件
  system.time({ # 统计程序运行时间
    datafile <- "data.ma505.csv" # 数据文件名称
    sqlquery("show tables") |> unlist() |> (\(x, i=grep("ma505", x)) x[i]) () |> sprintf(fmt="select * from %s") |> sqlquery() |> rbindlist() |> fwrite(datafile)
    # 查看数据文件
    list.files() |> grep(pattern=datafile, value=T) |> print() # 查看数据文件
    # 读取数据文件
    data <- fread(datafile, head=T) # 读取数据文件并返回结果，注意data是可以外部system.time访问的，但是无法在local以外进行访问
  }) |> print() # 打印程序运行时间
  data # 返回结果
}) # local 数据读取

# 交易时段的处理
local({
  market_trading_times <- function ( # 市场交易时间表
    line="09:00,10:15;10:30,11:30;13:30,15:00;21:00,23:00", # 开盘收盘的时点序列
    keys=c('早盘1','早盘2','下午盘','夜盘') # 交易时段名称
  ) ( \( # 依据交易时段，生成一个定义生成以时点标签key的定义函数
    tradesessions # 交易时段列表:一个 [(开始时间, 阶数时间)] 的记录序列， 用矩阵结构表达
  ) \( timex, # 时间向量
      startime=tradesessions[,1], # 交易时段开始
      endtime=tradesessions[,2] # 交易时段阶数
  ) { # x时点定义
    sapply(timex, \(x){ # 时点值
      key <- keys[( x>=startime & x<=endtime ), drop=T] # 判断时点x位于哪个交易时段
      if(length(key) >= 1) key else '非交易时段'
    }) # 时间向量的处理
 } ) (line |> strsplit("[,;]+") |> unlist() |> matrix(ncol=2, byrow=T)) # 解释时点序列为时段矩阵

 as.percent <- function (x) { # 转换成百分比
   low <- min(x)
   max <- max(x)
   (x - low) / ( max - low)
 } # 转换成百分比

 sqlquery("select * from t_ma505_20241219") |> # 读取合约数据
   mutate(TradeSession=market_trading_times()(substr(UpdateTime,1,5))) |> # 分析交易时段
   mutate(UpdateTime=as.POSIXct(paste(substr(PyctpCreateTime,1,10), UpdateTime), format="%Y-%m-%d %H:%M:%S")) |> # 时间分解 
   select(TradeSession, UpdateTime, LastPrice, Volume, OpenInterest) |> # 选择字段
   dplyr::filter(TradeSession=="早盘1" | TradeSession=="早盘2") |> # 指定具体的交易时段
   ggplot(aes(UpdateTime)) + facet_wrap(. ~ TradeSession, scales="free") + # 依据时段来分区
     geom_line( aes(y=LastPrice |> as.percent() ) ) + # 价格百分比
     geom_bar( aes(y=c(0, diff(Volume) |> as.percent() ) ), col="red", stat="identity" ) # 成交量
})

# 提取指定期货合约，使用 partial 函数，将参数列表 做一系列常量赋值语句 进而 省略了大括号的赋值操作，起到了精简代码的作用
sqlquery("show tables") |> with(Tables_in_ctp2) |> partial( \(x, i=grep("ru2505", x)) x[i] ) () 
# 等价于一下代码 ，从实际效果上看 写不写  partial 作用是一样的 都是 在 管道后面构造一个 带有一个首位参数是x,随后跟着一些依赖于x的默认参数的call对象,
# 但是partial ( \(x, i=grep("ru2505", x)) x[i] ) ()  会比单纯的 ( \(x, i=grep("ru2505", x) ) x[i]) ()  清晰一点，提醒了这里有一个partial 调用，这也是为何写partial的原因
sqlquery("show tables") |> with(Tables_in_ctp2) |> ( \(x, i=grep("ru2505", x) ) x[i]) () 

# 于是，可以把 形参列表作为语句的执行区域：编写以下的 读取tickdata数据 的函数,  之所以使用partial而不是直接lamda 是为了 便于识别
tickdatas.ma505 <- sqlquery("show tables") |> with(Tables_in_ctp2) |> partial( \(x, i=grep("ma505", x)) x[i] ) () |>  # 提取橡胶ru2505合约
  partial( \( # 定义一个函数把交易数据tickdata全部都给读出来
      tbls,  # 各个交易数据的数据表名, t_{合约代码的小写}_{日期时间戳}
      sqls=sprintf("select * from %s", tbls),  # 读取各个交易日的成交数据的sql 语句
      tdates=sapply(tbls, \(tbl) gsub(".+_(\\d+{8})$", "\\1", tbl)) # 日期时间戳
    ) sqls |> sqlquery() |> structure(names=tdates) # 执行SQL查询语句并将结果组装成list列表
  ) (); tickdatas.ma505  #  获取所有tickdata数据

# 把各个数据表的数据合并成一个列表tibble
tibble.ma505 <- tickdatas.ma505 |> partial( \( # 数据合并函数
    x, # tickdatas.ma505 交易数据
    dates=names(x) |> gsub("(\\d{4})(\\d{2})(\\d{2})", "\\1-\\2-\\3", x=_ ) # 解析成年月日的日期形式
  ) Reduce(x=seq(x), \(acc,i) rbind(acc, x[[i]] |> mutate ( # 修改数据列UpdateTime补充数据日期
    UpdateTime=paste(dates[i], UpdateTime) |> strptime(format="%Y-%M-%d %H:%M:%S") ) # 修改更新时间
  ), init=data.frame()) ) () |> partial( \(x) x |> mutate(Id=seq(nrow(x))) ) () ; tibble.ma505 # 数据合并函数(统一整个Id) 
# 数据写出
write.csv(tibble.ma505, "tibble.ma505.csv") # 写入数据文件

# ----------------------------------------------------------------------------------------------------------------

# TickData 的交易行情辨别
local({ # 本地测试
  library(jsonlite) # fromJSON 所在库
  tdfm <- sqlquery("select * from t_ma505_20241219") # 检索出TickData数据

  # 标记逻辑的规则枚举
  # 1) 确定持仓状态:持仓量上涨就是开仓,持仓量不变就是换手,持仓量降低就是平仓
  # 2) 在特定的持仓状态下,依据价格变化推断,多空方向：
  # 2.1) 开仓时，价格上涨为多开, 价格下跌为空开，价格不变为双开
  # 2.2) 平仓时，价格上涨为空平, 价格下跌为多平，价格不变为双平
  # 2.3)换手时, 价格上涨为多换，价格下跌为空换，价格不变为双换，多方边变空方，空方变多方
  # 3) 符号与数字意义：
  # 3.1) 键名字段, PChg:价格增长, VChg:现手成交, OChg:开仓数量, Name:规则名称, Description:规则说明
  # 3.2) 数字含义, 1:增长, 0:不变, -1:下降
  pvo_rules <- # Json 格式的规则定义
    '[
       {"PChg":1,"VChg":1,"OChg":1,"Name":"多开+","Description":"价格上涨，成交量上涨，持仓量上涨"},
       {"PChg":0,"VChg":1,"OChg":1,"Name":"双开+","Description":"价格不变，成交量上涨，持仓量上涨"},
       {"PChg":-1,"VChg":1,"OChg":1,"Name":"空开+","Description":"价格下降，成交量上涨，持仓量上涨"},
       {"PChg":1,"VChg":0,"OChg":1,"Name":"多开0","Description":"价格上涨，成交量不变，持仓量上涨"},
       {"PChg":0,"VChg":0,"OChg":1,"Name":"双开0","Description":"价格不变，成交量不变，持仓量上涨"},
       {"PChg":-1,"VChg":0,"OChg":1,"Name":"空开0","Description":"价格下降，成交量不变，持仓量上涨"},
       {"PChg":1,"VChg":-1,"OChg":1,"Name":"多开-","Description":"价格上涨，成交量下降，持仓量上涨"},
       {"PChg":0,"VChg":-1,"OChg":1,"Name":"双开-","Description":"价格不变，成交量下降，持仓量上涨"},
       {"PChg":-1,"VChg":-1,"OChg":1,"Name":"空开-","Description":"价格下降，成交量下降，持仓量上涨"},
       {"PChg":1,"VChg":1,"OChg":0,"Name":"多换+","Description":"价格上涨，成交量上涨，持仓量不变"},
       {"PChg":0,"VChg":1,"OChg":0,"Name":"双换+","Description":"价格不变，成交量上涨，持仓量不变"},
       {"PChg":-1,"VChg":1,"OChg":0,"Name":"空换+","Description":"价格下降，成交量上涨，持仓量不变，一部分空方加仓，一部分空方平仓，空方加仓导致价格下跌"},
       {"PChg":1,"VChg":0,"OChg":0,"Name":"多换0","Description":"价格上涨，成交量不变，持仓量不变，一部分多方加仓，一部分多方平仓，多方加仓导致价格上涨"},
       {"PChg":0,"VChg":0,"OChg":0,"Name":"换手0","Description":"价格不变，成交量不变，持仓量不变"},
       {"PChg":-1,"VChg":0,"OChg":0,"Name":"多换0","Description":"价格下降，成交量不变，持仓量不变"},
       {"PChg":1,"VChg":-1,"OChg":0,"Name":"多换-","Description":"价格上涨，成交量下降，持仓量不变"},
       {"PChg":0,"VChg":-1,"OChg":0,"Name":"换手-","Description":"价格不变，成交量下降，持仓量不变"},
       {"PChg":-1,"VChg":-1,"OChg":0,"Name":"多换-","Description":"价格下降，成交量下降，持仓量不变"},
       {"PChg":1,"VChg":1,"OChg":-1,"Name":"空平+","Description":"价格上涨，成交量上涨，持仓量下降"},
       {"PChg":0,"VChg":1,"OChg":-1,"Name":"双平+","Description":"价格不变，成交量上涨，持仓量下降"},
       {"PChg":-1,"VChg":1,"OChg":-1,"Name":"多平+","Description":"价格下降，成交量上涨，持仓量下降"},
       {"PChg":1,"VChg":0,"OChg":-1,"Name":"空平0","Description":"价格上涨，成交量不变，持仓量下降"},
       {"PChg":0,"VChg":0,"OChg":-1,"Name":"双平0","Description":"价格不变，成交量不变，持仓量下降"},
       {"PChg":-1,"VChg":0,"OChg":-1,"Name":"多平0","Description":"价格下降，成交量不变，持仓量下降"},
       {"PChg":1,"VChg":-1,"OChg":-1,"Name":"空平-","Description":"价格上涨，成交量下降，持仓量下降"},
       {"PChg":0,"VChg":-1,"OChg":-1,"Name":"双平-","Description":"价格不变，成交量下降，持仓量下降"},
       {"PChg":-1,"VChg":-1,"OChg":-1,"Name":"多平-","Description":"价格下降，成交量下降，持仓量下降"}
    ]' |> fromJSON() # 转换成data.frame
  write.csv(pvo_rules,"pvo_rules.csv",row.names = T) # 写入规则文件
  pvo_rules <- read.csv("pvo_rules.csv", head=T) # 读取规则文件

  # 标识辨析
  identify <- function(PChg, VChg, OChg, pvo_rules=pvo_rules) {
    if(c(PChg,VChg,OChg) |> sapply(is.na) |> any()){ # 存在无效数据的情况
      list(PChg=PChg, VChg=VChg, OChg=VChg, Name="无效", Description="无效") # 起始数据无效
    } else {# 数据有效
      pvo_rules[ pvo_rules$PChg==sign(PChg) & pvo_rules$VChg==sign(VChg) & pvo_rules$OChg==sign(OChg), ,drop=T ] # 检索相应位置条目
    }
  } # identify

  # 数据分类
  tdfm |> tail(20) |> mutate (
    PChg = c(NA, diff(LastPrice)),
    VChg = c(NA, diff(Volume)),
    OChg = c(NA, diff(OpenInterest)),
    Name = pmap_chr(list(PChg, VChg, OChg), ~ identify (..1, ..2, ..3, pvo_rules)$Name),
    Description = pmap_chr(list(PChg, VChg, OChg), ~ identify (..1, ..2, ..3, pvo_rules)$Description)
  ) |> select(Id, UpdateTime, LastPrice, PChg, VChg, OChg, Name, Description) |> arrange(-Id)
}) # local 本地测试

# ----------------------------------------------------------------------------------------------------------------

# 读取指定合约 tickdata table of 
# symbol 合约符号
# datepat 日期模式，如20241219
tdtbls_of <- \(symbol, datepat="\\d{8}") sqlquery("show tables") |> unlist() |> (\(x) x[grep(sprintf("^t_%s_%s", symbol, datepat), x)]) ()
# 读取指定合约的数据表列表-所有
tdtbls_of("ma501")
# 读取指定合约的数据表列表-指定日期
tdtbls_of("ma501", "20241219")

# 读取所有合约数据
tickdata_of <- \(symbol, datepat="\\d{8}") { 
  tdtbls <- tdtbls_of(symbol, datepat); # 交易数据表
  tdtbls |> sprintf(fmt="select * from %s") |> sqlquery() |> structure(names=tdtbls) 
}
# 读取合约数据-所有
tickdata_of("ma501")
# 读取合约数据-指定范围
tickdata_of("ma501", "202412(09|1[1-9])")

# 计算K线
# 将tickdata的dataframe  即 tdfm 转换成分钟线 
# tdfm tickdata 的数据
# tdate tickdata 所在的交易日期
compute_kline <- function(tdfm, tdate=Sys.Date()) { # 计算K线
  # Step 1: 创建 TickData  (依据更新时间进行数据排序）
  tickdata <- tdfm |> mutate(Period=substr(UpdateTime, 1, 5)) |> arrange(UpdateTime, UpdateMillisec) # 交易数据
  # Step 2: 创建 KlineData 
  pattern <- "%Y-%m-%d %H:%M" # 时间模式
  klinedata <- tickdata |> group_by(Period) |> mutate( # OHLC 数据生成
    Period=strptime(sprintf('%s %s', tdate, Period), pattern), # 日期时间
    Open=first(LastPrice), High=max(LastPrice), Low=min(LastPrice), Close=last(LastPrice), 
    ranking=row_number(desc(Id))  # 确保最后成交的tickdata排序为1，以便作为分钟线进行提取
  ) |> ungroup() |> dplyr::filter(ranking==1)  # 选择每个周期的最后一行作为kline数据数据线
  # Step 3: 计算成交量和开仓量的变化 
  kd <- klinedata |> mutate( # 计算分钟成交量和分钟持仓量变化
    Vol1m=Volume-dplyr::lag(Volume, default=Volume[1]), # 成交量-分钟增量
    OpenInt1m=OpenInterest-dplyr::lag(OpenInterest, default=OpenInterest[1]) # 持仓量-分钟增量
  ) # 带有OHLCV数据klinedata 
  # Step4: 包装成Period,OHLCV,OI的格式
  kd |> select(Period, Open, High, Low, Close, Volume=Vol1m, OpenInt1m, AccVol=Volume, AccOpenInt=OpenInterest) # 返回K线结果
} # compute_kline 

# 读取合约数据-指定范围 并且 转换成 K线
klinedata_of <- function(symbol, datepat="\\d{8}") {
  tickdata <- tickdata_of(symbol, datepat) # 获取交易数据
  datatbls <- names(tickdata) # tickdata的数据表名
  # 提取表名尾部的日期时间戳后缀用以标记tickdata所在日期时间
  tdates <- datatbls |> lapply(\(x) gsub(pattern=".+_(\\d{8})$", replacement="\\1",  x=x)  |> as.Date(format="%Y%m%d")) # K线日期
  tdatestamp <- tdates |> lapply(partial(strftime,format="%Y-%m-%d")) # 日期标记
  lapply(seq(tickdata), \(i) compute_kline(tickdata[[i]], tdates[[i]])) |> structure(names=tdatestamp) # 计算K线
}

# 生成K线数据, 结果为tibble的列表
klinedata <- klinedata_of("ma501", "202412(1[5-9])")

# 绘制K线图
with(klinedata, `2024-12-19`) |> with(xts(data.frame(Open,High,Low,Close,Volume), Period)) |> # 获取时间序列的数据
  head(100) |> chartSeries(theme="white", name="ma501-2024-12-19") # 编写K线图

# 读取数据库数据
"select Id,LastPrice,OpenInterest,Volume from t_rb2505_20241219" |> # sql 语句
  sqlquery() |> reshape2::melt(id.vars="Id") |> group_by(variable) |> mutate(avg=mean(value), # 分组计算波动值
    hi=max(value), lo=min(value), v=(value-avg)/(hi-lo)) |> ungroup() |> # 分组计算波动值volatile
  ggplot() + facet_grid(variable~.) + geom_line(aes(Id, v))

# ----------------------------------------------------------------------------------------------------------------
# 集群与并行计算
#
# 参考：vignette("gettingstartedParallel")
# doParallel介绍 ：
# The doParallel package provides a parallel backend for the foreach/%dopar% function using the parallel package of R 2.14.0 and later.
# To register doParallel to be used with foreach, you must call the registerDoParallel function.
# ---------------------------------------------------------------------------------------------------------------
system.time({ #  集群与并行计算
  print("集群与并行计算")
  pkgs <- strsplit("RMySQL,purrr,tidyverse,doParallel",  ",") |> unlist() # 并行计算需要各个程序包(doParallel)
  flags <- sapply(pkgs, \(p) substitute(require(p), list(p=p)) |> eval()) # 生成加载标志
  
  if(!all(flags)) { # 存在没有安装的程序包
    pkgs[!flags] |> install.packages() # 安装没有安装的程序包
    sapply(pkgs, \(p) substitute(require(p), list(p=p)) |> eval()) # 重新加载
  } # if
  
  # 定义集群运算函数
  # f 集群运算函数
  # vars2exports 待导出到集群节点上的变量名称字符串用逗号分割 或是一个 名称字符串向量
  execute <- function(f, vars2exports, ...) { # 集群运算
    ncores <- detectCores() - 1 # 集群核数量
    cl <- makeCluster(ncores) # 创建一个多核集群
    registerDoParallel(cl) # register doParallel to be used with foreach 将doParallel作为foreach的后端
    on.exit({ # 关闭集群
      stopImplicitCluster() #  explicitly close the implicitly created cluster. 对应于registerDoParallel(cl)
      stopCluster(cl) # 关闭
      print(sprintf("关闭集群, time: %s",Sys.time()))
    }) # 关闭集群
    varlist <- if(length(vars2exports)>1) vars2exports else strsplit(vars2exports, ",")[[1]]  # 需要导出到集群节点的object的名称
    clusterExport(cl, varlist) # 导出变量到各个集群节点
    print(sprintf("启动/运行集群:%s, cluster ncores:%s, time: %s", getDoParName(), getDoParWorkers(), Sys.time())) # 打印集群核数量
    
    f(...)  # 运行 集群运算 & 返回结果
  } # execute

  execute(\(...) { # 集群运算
    # 数据运算-获得所有甲醇ma期货合约的日交易数据tickdata
    sqlquery("show tables") |> compose(partial(grep, pattern="ma", value=T), unlist) ()  |> # 提取合约tickdata数据表名
      foreach( tbl=_,  .packages=pkgs ) %dopar%  { # 并行计算
        sql <- sprintf(fmt="select * from %s", tbl) # 生成查询SQL语句
        startime <-Sys.time() # 开始时间
        result <- sqlquery(sql) # SQL查询
        endtime <- Sys.time() # 结束时间
        # 结果返回
        list(tbl=tbl, sql=sql, result=result, # 节点程序运行结果
          startime=startime, endtime=endtime, duration=endtime-startime) # 结果返回
      } #  并行计算 foreach %dopar% 
   } , "sqlquery,dbfun") |> ( \(results) { # 结果集合的处理
        print(results) # 打印运算结果
   }) () # results 结果处理

}) # 集群与并行计算

# 耗费时间
#>
# user  system elapsed 
#   3.75    0.56   12.52 

# ---------------------------------------------------------------------------------------------------------------
# 单机非并发计算
# ---------------------------------------------------------------------------------------------------------------
system.time({ # 单机非并发计算
  print("单机非并发计算")
  # 数据运算-获得所有甲醇ma期货合约的日交易数据tickdata
  sqlquery("show tables") |> compose(partial(grep, pattern="ma", value=T), unlist) ()  |> lapply ( \(tbl) {  # 提取合约tickdata数据表名
      sql <- sprintf(fmt="select * from %s", tbl) # 生成查询SQL语句
      startime <-Sys.time() # 开始时间
      result <- sqlquery(sql) # SQL查询
      endtime <- Sys.time() # 结束时间
      # 结果返回
      list(tbl=tbl, sql=sql, result=result, # 节点程序运行结果
        startime=startime, endtime=endtime, duration=endtime-startime) # 结果返回
  }) |> ( \(results) { # 结果集合的处理
      print(results) # 打印运算结果
  }) () # results 结果处理
}) # 单机非并发计算

# 耗费时间
#>
#user  system elapsed 
#   4.72    0.38    6.80 
